



# æ•°æ®ç»“æ„ä¸ç®—æ³•å­¦ä¹ ç¬”è®°â€”â€”æ¨æ¡‚æ·¼æ€»ç»“

**å†™åœ¨å‰é¢ï¼š**

2022.06.20æ¼«é•¿çš„æš‘å‡å¼€å§‹äº†ï¼Œæ€»è¦åšäº›ä»€ä¹ˆã€‚åšå•¥ï¼Ÿâ€”â€”å½“ç„¶æ˜¯åšå¥½æœ¬æ‰‹å„¿ï¼ˆ2022å¹´é«˜è€ƒå­¦çš„è¯å“ˆå“ˆ~ï¼‰

ä»˜ä¸œæ¥å¤§å“¥çš„è¿™æœ¬ä¹¦æ˜¯2022.03.26è´­å…¥ï¼Œé‚£æ˜¯å¤§äºŒä¸‹å­¦æœŸçš„å¼€å­¦åä¸ä¹…ã€‚ä¸€ä¸ªå­¦æœŸå›«å›µåæ£çš„çœ‹äº†ä¸€éï¼Œæ²¡æœ‰getåˆ°ç²¾é«“éƒ¨åˆ†ï¼Œä»£ç çœ‹ç€å¾ˆæ˜ç™½ï¼Œè‡ªå·±å†™ç€é”™è¯¯ç™¾å‡ºã€‚äºæ˜¯è®¡åˆ’åˆ©ç”¨å¥½è¿™ä¸ªç¨å¾®æ¼«é•¿çš„æš‘å‡ï¼Œè®¤è®¤çœŸçœŸå­¦å¥½æ•°æ®ç»“æ„ä¸ç®—æ³•ã€‚

æœ¬æ€»ç»“æ˜¯æ¨æ¡‚æ·¼åŒå­¦åŸºäºåŠ›æ‰£å¹³å°çš„é¢˜ç›®ï¼Œå‚è€ƒä»˜ä¸œæ¥å¤§å“¥çš„è§£é¢˜æ€è·¯ç¼–å†™ï¼›ä¸œæ¥å¤§å“¥æ¯é“é¢˜éƒ½ç»™å‡ºäº†åŸºäºJavaçš„è§£é¢˜æ€è·¯ï¼Œä½†æ˜¯ç›®å‰é˜¶æ®µæœ¬äººJavaè¯­è¨€æŒæ¡ä¸€èˆ¬ã€‚äºæ˜¯ä¹ï¼Œå€Ÿé‰´ä¸œæ¥å¤§å“¥çš„æ€è·¯ï¼Œå°†é¢˜ç›®å…¨éƒ¨è¿ç”¨pythonè¯­è¨€å®ç°ã€‚éšç€æœ¬äººçš„ä¸æ–­å­¦ä¹ ç§¯ç´¯ï¼Œå®Œå–„åä»£ç ä¼šå…¨éƒ¨å¼€æºåˆ°æ¨æ¡‚æ·¼çš„GitHubä»“åº“ä¸­ï¼Œå±Šæ—¶ï¼Œæ¬¢è¿å„ä½å¤§ä½¬è¯„é˜…æ–§æ­£ï¼›æ¬¢è¿å„ä½å¿—åŒé“åˆçš„åŒå¿—äº¤æµå­¦ä¹ ï¼

æœ¬äººç§‰æŒä¸œæ¥å¤§å“¥çš„ç†å¿µâ€”â€”è‡´åŠ›äºæŠŠç®—æ³•è®²æ¸…æ¥šï¼

å‚è€ƒå¼•ç”¨æ–‡ç« æ¥æºï¼šlabuladongå°ç«™

è®¡ç®—æœºä¸­æ•°æ®ç»“æ„çš„åˆ†ç±»ï¼š

å¸¸è§çš„æ•°æ®ç»“æ„å¯åˆ†ä¸ºã€Œçº¿æ€§æ•°æ®ç»“æ„ã€ä¸ã€Œéçº¿æ€§æ•°æ®ç»“æ„ã€ï¼Œå…·ä½“ä¸ºï¼šã€Œæ•°ç»„ã€ã€ã€Œé“¾è¡¨ã€ã€ã€Œæ ˆã€ã€ã€Œé˜Ÿåˆ—ã€ã€ã€Œæ ‘ã€ã€ã€Œå›¾ã€ã€ã€Œæ•£åˆ—è¡¨ã€ã€ã€Œå †ã€ã€‚

## åŒæŒ‡é’ˆæŠ€å·§åœ¨é“¾è¡¨ä¸æ•°ç»„ä¸­çš„è¿ç”¨

åŒæŒ‡é’ˆåˆ†ç±»ï¼š1.**å¿«æ…¢æŒ‡é’ˆ** 2.**å·¦å³æŒ‡é’ˆ**

åŠ›æ‰£ä¸­çš„å¯¹åº”é¢˜ç›®å¦‚ä¸‹ï¼š

æ•°ç»„ï¼š

| LeetCode                                                     | åŠ›æ‰£                                                         | éš¾åº¦ |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) | [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode.cn/problems/longest-palindromic-substring/) | ğŸŸ     |
| [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) | [26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) | ğŸŸ¢    |
| [27. Remove Element](https://leetcode.com/problems/remove-element/) | [27. ç§»é™¤å…ƒç´ ](https://leetcode.cn/problems/remove-element/) | ğŸŸ¢    |
| [83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/) | [83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) | ğŸŸ¢    |
| [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | [167. ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) | ğŸŸ¢    |
| [283. Move Zeroes](https://leetcode.com/problems/move-zeroes/) | [283. ç§»åŠ¨é›¶](https://leetcode.cn/problems/move-zeroes/)     | ğŸŸ¢    |
| [344. Reverse String](https://leetcode.com/problems/reverse-string/) | [344. åè½¬å­—ç¬¦ä¸²](https://leetcode.cn/problems/reverse-string/) | ğŸŸ¢    |

åœ¨å¤„ç†æ•°ç»„å’Œé“¾è¡¨ç›¸å…³é—®é¢˜æ—¶ï¼ŒåŒæŒ‡é’ˆæŠ€å·§æ˜¯ç»å¸¸ç”¨åˆ°çš„ï¼ŒåŒæŒ‡é’ˆæŠ€å·§ä¸»è¦åˆ†ä¸ºä¸¤ç±»ï¼š**å·¦å³æŒ‡é’ˆ**å’Œ**å¿«æ…¢æŒ‡é’ˆ**ã€‚

æ‰€è°“å·¦å³æŒ‡é’ˆï¼Œå°±æ˜¯ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œæˆ–è€…**ç›¸èƒŒè€Œè¡Œ**ï¼›è€Œæ‰€è°“å¿«æ…¢æŒ‡é’ˆï¼Œå°±æ˜¯ä¸¤ä¸ªæŒ‡é’ˆ**åŒå‘è€Œè¡Œ**ï¼Œä¸€å¿«ä¸€æ…¢ã€‚

å¯¹äºå•é“¾è¡¨æ¥è¯´ï¼Œå¤§éƒ¨åˆ†æŠ€å·§éƒ½å±äºå¿«æ…¢æŒ‡é’ˆã€‚

åœ¨æ•°ç»„ä¸­å¹¶æ²¡æœ‰çœŸæ­£æ„ä¹‰ä¸Šçš„æŒ‡é’ˆï¼Œä½†æˆ‘ä»¬å¯ä»¥æŠŠ**ç´¢å¼•**å½“åšæ•°ç»„ä¸­çš„æŒ‡é’ˆï¼Œè¿™æ ·ä¹Ÿå¯ä»¥åœ¨æ•°ç»„ä¸­æ–½å±•åŒæŒ‡é’ˆæŠ€å·§ï¼Œ**æœ¬æ–‡å…ˆè®²æ•°ç»„ç›¸å…³çš„åŒæŒ‡é’ˆç®—æ³•**ï¼Œ**å†è®²é“¾è¡¨æœ‰å…³çš„åŒæŒ‡é’ˆç®—æ³•ã€‚**

### Array~å¿«æ…¢æŒ‡é’ˆæŠ€å·§

**æ•°ç»„é—®é¢˜ä¸­æ¯”è¾ƒå¸¸è§çš„å¿«æ…¢æŒ‡é’ˆæŠ€å·§ï¼Œæ˜¯è®©ä½ åŸåœ°ä¿®æ”¹æ•°ç»„**ã€‚

ç®€å•è§£é‡Šä¸€ä¸‹ä»€ä¹ˆæ˜¯åŸåœ°ä¿®æ”¹ï¼š

å¦‚æœä¸æ˜¯åŸåœ°ä¿®æ”¹çš„è¯ï¼Œæˆ‘ä»¬ç›´æ¥ new ä¸€ä¸ª `int[]` æ•°ç»„ï¼ŒæŠŠå»é‡ä¹‹åçš„å…ƒç´ æ”¾è¿›è¿™ä¸ªæ–°æ•°ç»„ä¸­ï¼Œç„¶åè¿”å›è¿™ä¸ªæ–°æ•°ç»„å³å¯ã€‚

ä½†æ˜¯ç°åœ¨é¢˜ç›®è®©ä½ åŸåœ°åˆ é™¤ï¼Œä¸å…è®¸ new æ–°æ•°ç»„ï¼Œåªèƒ½åœ¨åŸæ•°ç»„ä¸Šæ“ä½œï¼Œç„¶åè¿”å›ä¸€ä¸ªé•¿åº¦ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡è¿”å›çš„é•¿åº¦å’ŒåŸå§‹æ•°ç»„å¾—åˆ°æˆ‘ä»¬å»é‡åçš„å…ƒç´ æœ‰å“ªäº›äº†ã€‚

ç”±äºæ•°ç»„å·²ç»æ’åºï¼Œæ‰€ä»¥é‡å¤çš„å…ƒç´ ä¸€å®šè¿åœ¨ä¸€èµ·ï¼Œæ‰¾å‡ºå®ƒä»¬å¹¶ä¸éš¾ã€‚ä½†å¦‚æœæ¯æ‰¾åˆ°ä¸€ä¸ªé‡å¤å…ƒç´ å°±ç«‹å³åŸåœ°åˆ é™¤å®ƒï¼Œç”±äºæ•°ç»„ä¸­åˆ é™¤å…ƒç´ æ¶‰åŠæ•°æ®æ¬ç§»ï¼Œæ•´ä¸ªæ—¶é—´å¤æ‚åº¦æ˜¯ä¼šè¾¾åˆ° `O(N^2)`ã€‚

é«˜æ•ˆè§£å†³è¿™é“é¢˜å°±è¦ç”¨åˆ°å¿«æ…¢æŒ‡é’ˆæŠ€å·§ï¼š

æˆ‘ä»¬è®©æ…¢æŒ‡é’ˆ `slow` èµ°åœ¨åé¢ï¼Œå¿«æŒ‡é’ˆ `fast` èµ°åœ¨å‰é¢**æ¢è·¯**ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸é‡å¤çš„å…ƒç´ å°±èµ‹å€¼ç»™ `slow` å¹¶è®© `slow` å‰è¿›ä¸€æ­¥ã€‚

è¿™æ ·ï¼Œå°±ä¿è¯äº† `nums[0..slow]` éƒ½æ˜¯æ— é‡å¤çš„å…ƒç´ ï¼Œå½“ `fast` æŒ‡é’ˆéå†å®Œæ•´ä¸ªæ•°ç»„ `nums` åï¼Œ`nums[0..slow]` å°±æ˜¯æ•´ä¸ªæ•°ç»„å»é‡ä¹‹åçš„ç»“æœã€‚

```Python
//Javaå®ç°
int removeDuplicates(int[] nums){
    if (nums.length == 0)
    {
        return 0;
    }
    int slow = 0,fast = 0;
    while (fast < nums.length)
    {
        if (nums[fast] != nums[slow])
        {
            slow++;
            nums[slow] = nums[fast];
                
        }
        fast++; 
    }
    return slow + 1;
}
#pythonå®ç°
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if(len(nums) == 0):
            return 0
        #can't assign to literalçš„é”™è¯¯æ¥æºæ˜¯slow=0ï¼Œfast=0å†™åœ¨äº†ä¸€è¡Œä¸­
        #è¦ä¹ˆç”¨é€—å·éš”å¼€ï¼Œç”¨ä¹ˆåˆ†æˆä¸¤è¡Œå†™
        slow=0
        fast=0
        while(fast < len(nums)):
            if(nums[fast] != nums[slow]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1

        return slow + 1
```

åŒç†ï¼Œå°†æœ¬é¢˜çš„æ€æƒ³ç”¨äºé“¾è¡¨å»é‡çš„ä»£ç å®ç°ä¸ºï¼š

```Python
ListNode deleteDuplicates(ListNode head) {
    if (head == null) return null;
    ListNode slow = head, fast = head;
    while (fast != null) {
        if (fast.val != slow.val) {
            // nums[slow] = nums[fast];
            slow.next = fast;
            // slow++;
            slow = slow.next;
        }
        // fast++
        fast = fast.next;
    }
    // æ–­å¼€ä¸åé¢é‡å¤å…ƒç´ çš„è¿æ¥
    slow.next = null;
    return head;
}
```

ç±»ä¼¼çš„ï¼Œä¾‹å¦‚åŠ›æ‰£ä¸­çš„**ç§»åŠ¨é›¶**é¢˜ç›®ï¼š

ç»™å®šä¸€ä¸ªæ•°ç»„ `nums`ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ `0` ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚

æœ¬è´¨å°±æ˜¯æ•°ç»„å»é‡åå°†å°¾å·´éƒ¨åˆ†å…ƒç´ æ”¹ä¸º0

```Python
class Solution(object):
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        #è€å¥—è·¯ï¼Œè®¾ç½®å¿«æ…¢æŒ‡é’ˆ
        slow=0
        fast=0
        #æ ¸å¿ƒä»£ç åŒºï¼ŒåŒºåˆ†ä¸åŒç›®æ ‡å€¼çš„è®¾ç½®
        while(fast <len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        #ä¸å‰é¢é¢˜å”¯ä¸€çš„ä¸åŒç‚¹ï¼Œæ˜¯å°†æ•°ç»„å»é‡åå°¾éƒ¨å…ƒç´ ä¿®æ”¹ä¸º0ï¼Œæ­¤å¤„æˆ‘ç”¨çš„forå¾ªç¯ï¼Œæœ‰å…¶ä»–æ–°æ–¹æ³•æ¬¢è¿å¤§ä½¬ä»¬ä¿®æ”¹æå‡ºæ„è§
        for i in range(slow,len(nums)):
            nums[i] = 0
```

#### æ•°ç»„ç§»é™¤å…ƒç´ 

```python3
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow,fast = 0,0
        while(fast < len(nums)):
            if(nums[fast] != val):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

#### ç§»é™¤æ•°ç»„ä¸­çš„é‡å¤å…ƒç´ 

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow,fast = 0,0
        while(fast < len(nums)):
            if(nums[fast] != nums[slow]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return slow + 1
```

#### **å»é‡çš„æ ¸å¿ƒä»£ç å—**

```python
while(fast <len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
```

å¯¹äºæ ¸å¿ƒä»£ç å—è€Œè¨€ï¼Œåœ¨ç†Ÿç»ƒä½¿ç”¨çš„æƒ…å†µä¸‹è¦è®°ç‰¢ï¼Œæ–¹ä¾¿ååºå†™ç¨‹åºæ˜¯æ•ˆç‡æé«˜ã€‚

### Array~å·¦å³æŒ‡é’ˆæŠ€å·§

#### äºŒåˆ†æŸ¥æ‰¾ç®—æ³•

|                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) |  ğŸŸ    |
| [704. Binary Search](https://leetcode.com/problems/binary-search/) | [704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode.cn/problems/binary-search/) |  ğŸŸ¢   |

é¦–å…ˆä»‹ç»ä»¥ä¸‹äºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ¡†æ¶ï¼š

å…¶ä¸­ `...` æ ‡è®°çš„éƒ¨åˆ†ï¼Œå°±æ˜¯å¯èƒ½å‡ºç°ç»†èŠ‚é—®é¢˜çš„åœ°æ–¹ï¼Œå½“ä½ è§åˆ°ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ—¶ï¼Œé¦–å…ˆæ³¨æ„è¿™å‡ ä¸ªåœ°æ–¹ã€‚åæ–‡ç”¨å®ä¾‹åˆ†æè¿™äº›åœ°æ–¹èƒ½æœ‰ä»€ä¹ˆæ ·çš„å˜åŒ–ã€‚

**å¦å¤–æå‰è¯´æ˜ä¸€ä¸‹ï¼Œè®¡ç®— `mid` æ—¶éœ€è¦é˜²æ­¢æº¢å‡º**ï¼Œä»£ç ä¸­ `left + (right - left) / 2` å°±å’Œ `(left + right) / 2` çš„ç»“æœç›¸åŒï¼Œä½†æ˜¯æœ‰æ•ˆé˜²æ­¢äº† `left` å’Œ `right` å¤ªå¤§ï¼Œç›´æ¥ç›¸åŠ å¯¼è‡´æº¢å‡ºçš„æƒ…å†µã€‚

```java
def binarySearch(int[] nums, int target) {
    #è®¾ç½®å·¦å³æŒ‡é’ˆ
    int left = 0, right = ...;

    while(...) {
        #å…³é”®åœ¨midå€¼çš„è®¾å®šä¸å·¦å³è¾¹ç•Œç¡®å®š
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

äºŒåˆ†æŸ¥æ‰¾å¹¶ä¸ç®€å•ï¼ŒKnuth å¤§ä½¬ï¼ˆè‘—æœ‰å¤§éƒ¨å¤´ã€Šè®¡ç®—æœºç¨‹åºè®¾è®¡ã€‹ä¸€ä¹¦ï¼Œæ— æ•°ç¨‹åºå‘˜çš„åœ£ç»ï¼‰éƒ½è¯´äºŒåˆ†æŸ¥æ‰¾ï¼š**æ€è·¯å¾ˆç®€å•ï¼Œç»†èŠ‚æ˜¯é­”é¬¼**ã€‚äºŒåˆ†æŸ¥æ‰¾çœŸæ­£çš„å‘æ ¹æœ¬å°±ä¸æ˜¯é‚£äº›æœ‰å…³äºæº¢å‡ºçš„ç»†èŠ‚é—®é¢˜ï¼Œè€Œæ˜¯åœ¨äºåˆ°åº•è¦ç»™ `mid` åŠ ä¸€è¿˜æ˜¯å‡ä¸€ï¼Œwhile é‡Œåˆ°åº•ç”¨ `<=` è¿˜æ˜¯ `<`ã€‚

å‡ ä¸ªæœ€å¸¸ç”¨çš„äºŒåˆ†æŸ¥æ‰¾åœºæ™¯ï¼šå¯»æ‰¾ä¸€ä¸ªæ•°ã€å¯»æ‰¾å·¦ä¾§è¾¹ç•Œã€å¯»æ‰¾å³ä¾§è¾¹ç•Œã€‚

æˆ‘ä»¬è¦**æ·±å…¥ç»†èŠ‚**ï¼Œæ¯”å¦‚ä¸ç­‰å·æ˜¯å¦åº”è¯¥å¸¦ç­‰å·ï¼Œ`mid` æ˜¯å¦åº”è¯¥åŠ ä¸€ç­‰ç­‰ã€‚åˆ†æè¿™äº›ç»†èŠ‚çš„å·®å¼‚ä»¥åŠå‡ºç°è¿™äº›å·®å¼‚çš„åŸå› ï¼Œä¿è¯ä½ èƒ½çµæ´»å‡†ç¡®åœ°å†™å‡ºæ­£ç¡®çš„äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ã€‚

å¤§å®¶å†™äºŒåˆ†æ³•ç»å¸¸å†™ä¹±ï¼Œä¸»è¦æ˜¯å› ä¸º**å¯¹åŒºé—´çš„å®šä¹‰æ²¡æœ‰æƒ³æ¸…æ¥šï¼ŒåŒºé—´çš„å®šä¹‰å°±æ˜¯ä¸å˜é‡**ã€‚è¦åœ¨äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹ä¸­ï¼Œä¿æŒä¸å˜é‡ï¼Œå°±æ˜¯åœ¨whileå¯»æ‰¾ä¸­æ¯ä¸€æ¬¡è¾¹ç•Œçš„å¤„ç†éƒ½è¦åšæŒæ ¹æ®åŒºé—´çš„å®šä¹‰æ¥æ“ä½œï¼Œè¿™å°±æ˜¯**å¾ªç¯ä¸å˜é‡**è§„åˆ™ã€‚

å†™äºŒåˆ†æ³•ï¼ŒåŒºé—´çš„å®šä¹‰ä¸€èˆ¬ä¸ºä¸¤ç§ï¼Œå·¦é—­å³é—­å³[left, right]ï¼Œæˆ–è€…å·¦é—­å³å¼€å³[left, right)ã€‚

ä»æœ¬ä¹¦ä¸­å­¦åˆ°äº†ï¼Œåœ¨åˆ†æäºŒåˆ†æŸ¥æ‰¾æ—¶ï¼Œå¯¹äºé€‰æ‹©åˆ†æ”¯ç»“æ„if-elseå¾ˆå°‘ä½¿ç”¨ï¼Œè€Œæ˜¯ç”¨**else if** å–ä»£ï¼Œè¿™æ ·å¯ä»¥å±•ç¤ºäºŒåˆ†æŸ¥æ‰¾çš„æ‰€æœ‰ç»†èŠ‚ã€‚

##### å¯»æ‰¾ä¸€ä¸ªæ•°

è¿™æ®µä»£ç å¯ä»¥è§£å†³åŠ›æ‰£ç¬¬ 704 é¢˜ã€Œ [äºŒåˆ†æŸ¥æ‰¾](https://leetcode.cn/problems/binary-search/)ã€ã€‚

ä¸‹é¢æå‡ºè§£å†³æœ¬é¢˜éœ€è¦å…³æ³¨çš„ç»†èŠ‚ï¼š

**æœç´¢ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæœç´¢åŒºé—´ä¸¤ç«¯é—­**ï¼›**whileæ¡ä»¶å¸¦ç­‰å·**ï¼Œå¦åˆ™éœ€è¦æ‰“è¡¥ä¸ã€‚

ifç›¸ç­‰å°±è¿”å›ï¼Œå…¶ä»–çš„æ˜¯ç”­æ“å¿ƒï¼›**midå¿…é¡»åŠ å‡ä¸€**ï¼Œå› ä¸ºåŒºé—´ä¸¤ç«¯é—­ã€‚

whileç»“æŸå°±å‡‰å‡‰ï¼Œå‡„å‡„æƒ¨æƒ¨è¿”-1.

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        left = 0
        right = len(nums)-1 #æ˜“é”™ç‚¹
        while(left <= right):
            mid = left + (right - left)/2
            if(nums[mid] == target):
                return mid
            elif(nums[mid] < target):
                #å¯¹äºmidçš„æ“ä½œæ—¶äºŒåˆ†æŸ¥æ‰¾çš„ä¸€ä¸ªéš¾ç‚¹ã€‚
                left = mid + 1
            elif(nums[mid] > target):
                right = mid - 1
        return -1
```

**while(left <= right)çš„ç»ˆæ­¢æ¡ä»¶**æ˜¯ï¼šleft == right + 1->[right + 1,right]ã€‚

**while(left < right)çš„ç»ˆæ­¢æ¡ä»¶**æ˜¯ï¼šleft == right ->[left,right]ã€‚

##### å¯»æ‰¾å·¦ä¾§è¾¹ç•Œ

å·¦ä¾§è¾¹ç•Œæ˜¯å·¦é—­å³å¼€çš„æœç´¢åŒºé—´ï¼š**[left,right)**,å› æ­¤éœ€è¦æ³¨æ„whileçš„æ¡ä»¶æ˜¯**while(left<right)**ã€‚

right = len(nums)



##### å¯»æ‰¾å³ä¾§è¾¹ç•Œ

#### åè½¬ç³»åˆ—ä¸å›æ–‡

å›æ–‡æ¨¡æ¿ï¼š

```c++
bool isPalindrome(const string& s,int start,int end){
        for(int i = start,j = end;i < j;i++,j--){
            if(s[i] != s[j]){
                return false;
            }
        }
        return true;
```

##### è¿­ä»£åè½¬å•é“¾è¡¨

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return head
        pre = None
        tmp = None
        #åˆ‡è®°ç†è§£ç»ˆæ­¢æ¡ä»¶
        while(head != None):
            #è¿­ä»£åè½¬è¿‡ç¨‹
            tmp = head.next
            head.next = pre
            pre = head
            head = tmp
        return pre
```

##### é€’å½’åè½¬å•é“¾è¡¨

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        #ç‰¹æ®Šæƒ…å†µ
        if head == None or head.next == None:
            return head
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```

##### å›æ–‡é“¾è¡¨

```python
#æ•°ç»„æ¨¡æ‹Ÿ
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        length = 0
        tmp = head
        while tmp: #æ±‚é“¾è¡¨é•¿åº¦
            length += 1
            tmp = tmp.next
        
        result = [0] * length
        tmp = head
        index = 0
        while tmp: #é“¾è¡¨å…ƒç´ åŠ å…¥æ•°ç»„
            result[index] = tmp.val
            index += 1
            tmp = tmp.next
        
        i, j = 0, length - 1
        while i < j: # åˆ¤æ–­å›æ–‡
            if result[i] != result[j]:
                return False
            i += 1
            j -= 1
        return True
        
#åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if head == None or head.next == None:
            return True
        slow, fast = head, head
        while fast and fast.next:
            pre = slow
            slow = slow.next
            fast = fast.next.next
        
        pre.next = None # åˆ†å‰²é“¾è¡¨
        cur1 = head # å‰åŠéƒ¨åˆ†
        cur2 = self.reverseList(slow) # åè½¬ååŠéƒ¨åˆ†ï¼Œæ€»é“¾è¡¨é•¿åº¦å¦‚æœæ˜¯å¥‡æ•°ï¼Œcur2æ¯”cur1å¤šä¸€ä¸ªèŠ‚ç‚¹
        while cur1:
            if cur1.val != cur2.val:
                return False
            cur1 = cur1.next
            cur2 = cur2.next
        return True

    def reverseList(self, head: ListNode) -> ListNode:
        cur = head   
        pre = None
        while(cur!=None):
            temp = cur.next # ä¿å­˜ä¸€ä¸‹curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            cur.next = pre # åè½¬
            pre = cur
            cur = temp
        return pre
```

##### **åè½¬æ•´æ•°**

```python
class Solution:
    def reverse(self, x: int) -> int:
        if(x == 0):
            return 0
        if(x > 0):
            y = int(str(x)[::-1])
            return y if -2147483648<y<2147483647 else 0 
        if(x < 0):
            y = -int(str(abs(x))[::-1])
            return y if -2147483648<y<2147483647 else 0
```

##### **æœ€é•¿å›æ–‡å­—ç¬¦ä¸²**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ' '
        for i in range(len(s)):
            start = max(0,i-len(res)-1)
            tmp = s[start : i+1]
            #åˆ†æƒ…å†µï¼šsä¸­å«æœ‰å­—æ¯çš„ä¸ªæ•°
            if tmp == tmp[::-1]:
                res = tmp
            else:
                tmp = tmp[1:]
                if tmp == tmp[::-1]:
                    res = tmp
        return res
```

##### åè½¬å­—ç¬¦ä¸²

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        
        # è¯¥æ–¹æ³•å·²ç»ä¸éœ€è¦åˆ¤æ–­å¥‡å¶æ•°ï¼Œç»æµ‹è¯•åæ—¶é—´ç©ºé—´å¤æ‚åº¦æ¯”ç”¨ for i in range(right//2)æ›´ä½
        # æ¨èè¯¥å†™æ³•ï¼Œæ›´åŠ é€šä¿—æ˜“æ‡‚
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

### Linked List~åŒæŒ‡é’ˆæŠ€å·§

é“¾è¡¨ï¼š

| LeetCode                                                     | åŠ›æ‰£                                                         | éš¾åº¦ |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | [19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) | ğŸŸ     |
| [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/) | ğŸŸ¢    |
| [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) | [23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/) | ğŸ”´    |
| [86. Partition List](https://leetcode.com/problems/partition-list/) | [86. åˆ†éš”é“¾è¡¨](https://leetcode.cn/problems/partition-list/) | ğŸŸ     |
| [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | [141. ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/) | ğŸŸ¢    |
| [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) | [142. ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii/) | ğŸŸ     |
| [160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) | [160. ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists/) | ğŸŸ¢    |
| [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) | [876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/) | ğŸŸ¢    |

è§£å†³é—®é¢˜ï¼š

æœ¬èŠ‚çš„éš¾ç‚¹åœ¨äºï¼Œç›®å‰æ— æ³•çªç ´åœ¨åŠ›æ‰£ä¸­å¯¹äº**ã€Œè™šæ‹Ÿå¤´ç»“ç‚¹ã€**çš„å»ºç«‹ä½¿ç”¨ã€‚æ‰€ä»¥ä»£ç å…ˆæŒ‰ä¸œå“¥Javaå®ç°ï¼ŒåŠªåŠ›çªç ´éš¾ç‚¹åï¼Œå…¨éƒ¨æ›´æ–°ä¸ºpythonä»£ç ã€‚

#### è®¾è®¡é“¾è¡¨-å……åˆ†æŒæ¡

åœ¨é“¾è¡¨ç±»ä¸­å®ç°è¿™äº›åŠŸèƒ½ï¼š

-get(index)ï¼šè·å–é“¾è¡¨ä¸­ç¬¬ index ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœç´¢å¼•æ— æ•ˆï¼Œåˆ™è¿”å›-1ã€‚
-addAtHead(val)ï¼šåœ¨é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰**æ·»åŠ **ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹ã€‚æ’å…¥åï¼Œæ–°èŠ‚ç‚¹å°†æˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚
-addAtTail(val)ï¼šå°†å€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
-addAtIndex(index,val)ï¼šåœ¨é“¾è¡¨ä¸­çš„ç¬¬ index ä¸ªèŠ‚ç‚¹ä¹‹å‰æ·»åŠ å€¼ä¸º val  çš„èŠ‚ç‚¹ã€‚å¦‚æœ index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œåˆ™è¯¥èŠ‚ç‚¹å°†é™„åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index å¤§äºé“¾è¡¨é•¿åº¦ï¼Œåˆ™ä¸ä¼šæ’å…¥èŠ‚ç‚¹ã€‚å¦‚æœindexå°äº0ï¼Œåˆ™åœ¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹ã€‚
-deleteAtIndex(index)ï¼šå¦‚æœç´¢å¼• index æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­çš„ç¬¬ index ä¸ªèŠ‚ç‚¹ã€‚

```python
# å•é“¾è¡¨
class Node:
    
    def __init__(self, val):
        self.val = val
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head = Node(0)  # è™šæ‹Ÿå¤´éƒ¨èŠ‚ç‚¹
        self._count = 0  # æ·»åŠ çš„èŠ‚ç‚¹æ•°

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if 0 <= index < self._count:
            node = self._head
            for _ in range(index + 1):
                node = node.next
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self._count, val)

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index < 0:
            index = 0
        elif index > self._count:
            return

        # è®¡æ•°ç´¯åŠ 
        self._count += 1

        add_node = Node(val)
        prev_node, current_node = None, self._head
        for _ in range(index + 1):
            prev_node, current_node = current_node, current_node.next
        else:
            prev_node.next, add_node.next = add_node, current_node

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if 0 <= index < self._count:
            # è®¡æ•°-1
            self._count -= 1
            prev_node, current_node = None, self._head
            for _ in range(index + 1):
                prev_node, current_node = current_node, current_node.next
            else:
                prev_node.next, current_node.next = current_node.next, None


# åŒé“¾è¡¨
# ç›¸å¯¹äºå•é“¾è¡¨, Nodeæ–°å¢äº†prevå±æ€§
class Node:
    
    def __init__(self, val):
        self.val = val
        self.prev = None
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head, self._tail = Node(0), Node(0)  # è™šæ‹ŸèŠ‚ç‚¹
        self._head.next, self._tail.prev = self._tail, self._head
        self._count = 0  # æ·»åŠ çš„èŠ‚ç‚¹æ•°

    def _get_node(self, index: int) -> Node:
        # å½“indexå°äº_count//2æ—¶, ä½¿ç”¨_headæŸ¥æ‰¾æ›´å¿«, åä¹‹_tailæ›´å¿«
        if index >= self._count // 2:
            # ä½¿ç”¨prevå¾€å‰æ‰¾
            node = self._tail
            for _ in range(self._count - index):
                node = node.prev
        else:
            # ä½¿ç”¨nextå¾€åæ‰¾
            node = self._head   
            for _ in range(index + 1):
                node = node.next
        return node

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if 0 <= index < self._count:
            node = self._get_node(index)
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self._update(self._head, self._head.next, val)

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self._update(self._tail.prev, self._tail, val)

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index < 0:
            index = 0
        elif index > self._count:
            return
        node = self._get_node(index)
        self._update(node.prev, node, val)

    def _update(self, prev: Node, next: Node, val: int) -> None:
        """
            æ›´æ–°èŠ‚ç‚¹
            :param prev: ç›¸å¯¹äºæ›´æ–°çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
            :param next: ç›¸å¯¹äºæ›´æ–°çš„åä¸€ä¸ªèŠ‚ç‚¹
            :param val:  è¦æ·»åŠ çš„èŠ‚ç‚¹å€¼
        """
        # è®¡æ•°ç´¯åŠ 
        self._count += 1
        node = Node(val)
        prev.next, next.prev = node, node
        node.prev, node.next = prev, next

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if 0 <= index < self._count:
            node = self._get_node(index)
            # è®¡æ•°-1
            self._count -= 1
            node.prev.next, node.next.prev = node.next, node.prev

ä»£ç éšæƒ³å½•ï¼šcarlsun-2
```

#### åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

è¿™ä¸ªç®—æ³•çš„é€»è¾‘ç±»ä¼¼äºæ‹‰æ‹‰é“¾ï¼Œä¸¤ä¸ªéœ€è¦åˆå¹¶çš„å•é“¾è¡¨ï¼Œç±»ä¼¼äºæ‹‰é“¾ä¸¤ä¾§çš„é”¯é½¿ï¼ŒæŒ‡é’ˆ `p` å°±å¥½åƒæ‹‰é“¾çš„æ‹‰ç´¢ï¼Œå°†ä¸¤ä¸ªæœ‰åºé“¾è¡¨åˆå¹¶ï¼›è¿‡ç¨‹ä¸è›‹ç™½è´¨çš„å½¢æˆè¿‡ç¨‹é«˜åº¦ç›¸ä¼¼ã€‚ï¼ˆé«˜ä¸­ç”Ÿç‰©çŸ¥è¯†çš„å¤ä¹ ï¼‰

è¿ç”¨çš„æŠ€å·§ï¼š**ä»£ç ä¸­è¿˜ç”¨åˆ°ä¸€ä¸ªé“¾è¡¨çš„ç®—æ³•é¢˜ä¸­æ˜¯å¾ˆå¸¸è§çš„ã€Œè™šæ‹Ÿå¤´ç»“ç‚¹ã€æŠ€å·§ï¼Œä¹Ÿå°±æ˜¯ `dummy` èŠ‚ç‚¹**ã€‚å¦‚æœä¸ä½¿ç”¨ `dummy` è™šæ‹ŸèŠ‚ç‚¹ï¼Œä»£ç ä¼šå¤æ‚å¾ˆå¤šï¼Œè€Œæœ‰äº† `dummy` èŠ‚ç‚¹è¿™ä¸ªå ä½ç¬¦ï¼Œå¯ä»¥é¿å…å¤„ç†ç©ºæŒ‡é’ˆçš„æƒ…å†µï¼Œé™ä½ä»£ç çš„å¤æ‚æ€§ã€‚

```python
//javaå®ç°
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;

        while (p1 != null && p2 != null) {
            // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
            // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next;
        }

        if (p1 != null) {
            p.next = p1;
        }

        if (p2 != null) {
            p.next = p2;
        }

        return dummy.next;
    }
}
```

è¿ç”¨é€’å½’æ–¹æ³•å®ç°åˆå¹¶ï¼šç¨‹åºçš„å¯è¯»æ€§é™ä½ï¼Œä½†ä»£ç æ›´ç®€æ´â€”â€”é€’å½’æ€æƒ³ååºæ€»ç»“ï¼Œéœ€è¦æŒæ¡å¥½ï¼

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def mergeTwoLists(self, list1, list2):
        """
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        if not list1: return list2
        if not list2: return list1
        if(list1.val <= list2.val):
            #é€’å½’æ ¸å¿ƒ
            list1.next = self.mergeTwoLists(list1.next,list2)
            return list1
        else:
            #é€’å½’æ ¸å¿ƒ
            list2.next = self.mergeTwoLists(list1,list2.next)
            return list2
```

#### é“¾è¡¨çš„åˆ†è§£

åœ¨åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨æ—¶è®©ä½ åˆäºŒä¸ºä¸€ï¼Œè€Œè¿™é‡Œéœ€è¦åˆ†è§£è®©ä½ æŠŠåŸé“¾è¡¨ä¸€åˆ†ä¸ºäºŒã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠåŸé“¾è¡¨åˆ†æˆä¸¤ä¸ªå°é“¾è¡¨ï¼Œä¸€ä¸ªé“¾è¡¨ä¸­çš„å…ƒç´ å¤§å°éƒ½å°äº `x`ï¼Œå¦ä¸€ä¸ªé“¾è¡¨ä¸­çš„å…ƒç´ éƒ½å¤§äºç­‰äº `x`ï¼Œæœ€åå†æŠŠè¿™ä¸¤æ¡é“¾è¡¨æ¥åˆ°ä¸€èµ·ï¼Œå°±å¾—åˆ°äº†é¢˜ç›®æƒ³è¦çš„ç»“æœã€‚

3ã€åˆå¹¶ `k` ä¸ªæœ‰åºé“¾è¡¨

åˆå¹¶ `k` ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘ç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼Œéš¾ç‚¹åœ¨äºï¼Œå¦‚ä½•å¿«é€Ÿå¾—åˆ° `k` ä¸ªèŠ‚ç‚¹ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸Šï¼Ÿ

è¿™é‡Œæˆ‘ä»¬å°±è¦ç”¨åˆ° [ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆäºŒå‰å †ï¼‰](https://labuladong.gitee.io/algo/2/21/62/) è¿™ç§æ•°æ®ç»“æ„ï¼ŒæŠŠé“¾è¡¨èŠ‚ç‚¹æ”¾å…¥ä¸€ä¸ªæœ€å°å †ï¼Œå°±å¯ä»¥æ¯æ¬¡è·å¾— `k` ä¸ªèŠ‚ç‚¹ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼š

```python
ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) return null;
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    ListNode dummy = new ListNode(-1);
    ListNode p = dummy;
    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
    PriorityQueue<ListNode> pq = new PriorityQueue<>(
        lists.length, (a, b)->(a.val - b.val));
    // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
    for (ListNode head : lists) {
        if (head != null)
            pq.add(head);
    }

    while (!pq.isEmpty()) {
        // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
        ListNode node = pq.poll();
        p.next = node;
        if (node.next != null) {
            pq.add(node.next);
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.next;
    }
    return dummy.next;
}
```

è¿™ä¸ªç®—æ³•æ˜¯é¢è¯•å¸¸è€ƒé¢˜ï¼Œå®ƒçš„æ—¶é—´å¤æ‚åº¦:

ä¼˜å…ˆé˜Ÿåˆ— `pq` ä¸­çš„å…ƒç´ ä¸ªæ•°æœ€å¤šæ˜¯ `k`ï¼Œæ‰€ä»¥ä¸€æ¬¡ `poll` æˆ–è€… `add` æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(logk)`ï¼›æ‰€æœ‰çš„é“¾è¡¨èŠ‚ç‚¹éƒ½ä¼šè¢«åŠ å…¥å’Œå¼¹å‡º `pq`ï¼Œ**æ‰€ä»¥ç®—æ³•æ•´ä½“çš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(Nlogk)`ï¼Œå…¶ä¸­ `k` æ˜¯é“¾è¡¨çš„æ¡æ•°ï¼Œ`N` æ˜¯è¿™äº›é“¾è¡¨çš„èŠ‚ç‚¹æ€»æ•°**ã€‚

#### å¯»æ‰¾å•é“¾è¡¨çš„ä¸­ç‚¹

åŠ›æ‰£ç¬¬ 876 é¢˜ã€Œ [é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/)ã€å°±æ˜¯è¿™ä¸ªé¢˜ç›®ï¼Œé—®é¢˜çš„å…³é”®ä¹Ÿåœ¨äºæˆ‘ä»¬æ— æ³•ç›´æ¥å¾—åˆ°å•é“¾è¡¨çš„é•¿åº¦ `n`ï¼Œå¸¸è§„æ–¹æ³•ä¹Ÿæ˜¯å…ˆéå†é“¾è¡¨è®¡ç®— `n`ï¼Œå†éå†ä¸€æ¬¡å¾—åˆ°ç¬¬ `n / 2` ä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯ä¸­é—´èŠ‚ç‚¹ã€‚

å¦‚æœæƒ³ä¸€æ¬¡éå†å°±å¾—åˆ°ä¸­é—´èŠ‚ç‚¹ï¼Œä¹Ÿéœ€è¦è€ç‚¹å°èªæ˜ï¼Œä½¿ç”¨ã€Œå¿«æ…¢æŒ‡é’ˆã€çš„æŠ€å·§ï¼š

æˆ‘ä»¬è®©ä¸¤ä¸ªæŒ‡é’ˆ `slow` å’Œ `fast` åˆ†åˆ«æŒ‡å‘é“¾è¡¨å¤´ç»“ç‚¹ `head`ã€‚

**æ¯å½“æ…¢æŒ‡é’ˆ `slow` å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ `fast` å°±å‰è¿›ä¸¤æ­¥ï¼Œè¿™æ ·ï¼Œå½“ `fast` èµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œ`slow` å°±æŒ‡å‘äº†é“¾è¡¨ä¸­ç‚¹**ã€‚

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def middleNode(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        #å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
        slow = head
        fast = head
        while(fast != None and fast.next != None):
            slow = slow.next
            fast = fast.next.next
        return slow
```

#### å¯»æ‰¾å•é“¾è¡¨çš„å€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹

ä»¥ä¸‹æ˜¯ä¸œå“¥æ–‡ç« ä¸­çš„è¯¦ç»†è§£é¢˜æ€è·¯ï¼š

ä»å‰å¾€åå¯»æ‰¾å•é“¾è¡¨çš„ç¬¬ `k` ä¸ªèŠ‚ç‚¹å¾ˆç®€å•ï¼Œä¸€ä¸ª for å¾ªç¯éå†è¿‡å»å°±æ‰¾åˆ°äº†ï¼Œä½†æ˜¯å¦‚ä½•å¯»æ‰¾ä»åå¾€å‰æ•°çš„ç¬¬ `k` ä¸ªèŠ‚ç‚¹å‘¢ï¼Ÿ

é‚£ä½ å¯èƒ½è¯´ï¼Œå‡è®¾é“¾è¡¨æœ‰ `n` ä¸ªèŠ‚ç‚¹ï¼Œå€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹å°±æ˜¯æ­£æ•°ç¬¬ `n - k + 1` ä¸ªèŠ‚ç‚¹ï¼Œä¸ä¹Ÿæ˜¯ä¸€ä¸ª for å¾ªç¯çš„äº‹å„¿å—ï¼Ÿ

æ˜¯çš„ï¼Œä½†æ˜¯ç®—æ³•é¢˜ä¸€èˆ¬åªç»™ä½ ä¸€ä¸ª `ListNode` å¤´ç»“ç‚¹ä»£è¡¨ä¸€æ¡å•é“¾è¡¨ï¼Œä½ ä¸èƒ½ç›´æ¥å¾—å‡ºè¿™æ¡é“¾è¡¨çš„é•¿åº¦ `n`ï¼Œè€Œéœ€è¦å…ˆéå†ä¸€éé“¾è¡¨ç®—å‡º `n` çš„å€¼ï¼Œç„¶åå†éå†é“¾è¡¨è®¡ç®—ç¬¬ `n - k + 1` ä¸ªèŠ‚ç‚¹ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªè§£æ³•éœ€è¦éå†ä¸¤æ¬¡é“¾è¡¨æ‰èƒ½å¾—åˆ°å‡ºå€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹

é‚£ä¹ˆï¼Œæˆ‘ä»¬èƒ½ä¸èƒ½**åªéå†ä¸€æ¬¡é“¾è¡¨**ï¼Œå°±ç®—å‡ºå€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹ï¼Ÿå¯ä»¥åšåˆ°çš„ï¼Œå¦‚æœæ˜¯é¢è¯•é—®åˆ°è¿™é“é¢˜ï¼Œé¢è¯•å®˜è‚¯å®šä¹Ÿæ˜¯å¸Œæœ›ä½ ç»™å‡ºåªéœ€éå†ä¸€æ¬¡é“¾è¡¨çš„è§£æ³•ã€‚

è¿™ä¸ªè§£æ³•å°±æ¯”è¾ƒå·§å¦™äº†ï¼Œå‡è®¾ `k = 2`ï¼Œæ€è·¯å¦‚ä¸‹ï¼š

é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆè®©ä¸€ä¸ªæŒ‡é’ˆ `p1` æŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œç„¶åèµ° `k` æ­¥ï¼š

ç°åœ¨çš„ `p1`ï¼Œåªè¦å†èµ° `n - k` æ­¥ï¼Œå°±èƒ½èµ°åˆ°é“¾è¡¨æœ«å°¾çš„ç©ºæŒ‡é’ˆäº†å¯¹å§ï¼Ÿ

è¶è¿™ä¸ªæ—¶å€™ï¼Œå†ç”¨ä¸€ä¸ªæŒ‡é’ˆ `p2` æŒ‡å‘é“¾è¡¨å¤´èŠ‚ç‚¹ `head`ï¼š

æ¥ä¸‹æ¥å°±å¾ˆæ˜¾ç„¶äº†ï¼Œè®© `p1` å’Œ `p2` åŒæ—¶å‘å‰èµ°ï¼Œ`p1` èµ°åˆ°é“¾è¡¨æœ«å°¾çš„ç©ºæŒ‡é’ˆæ—¶å‰è¿›äº† `n - k` æ­¥ï¼Œ`p2` ä¹Ÿä» `head` å¼€å§‹å‰è¿›äº† `n - k` æ­¥ï¼Œåœç•™åœ¨ç¬¬ `n - k + 1` ä¸ªèŠ‚ç‚¹ä¸Šï¼Œå³æ°å¥½åœé“¾è¡¨çš„å€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹ä¸Šï¼š

è¿™æ ·ï¼Œåªéå†äº†ä¸€æ¬¡é“¾è¡¨ï¼Œå°±è·å¾—äº†å€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹ `p2`ã€‚

ä¸œå“¥å¾ˆè¯¦ç»†åœ°è¯´äº†ä¸€å¤§å †ï¼Œå…¶å®ç®€å•æ€»ç»“èµ·æ¥å°±æ˜¯ï¼š**å…ˆåˆ©ç”¨forå¾ªç¯è®©å¿«æŒ‡é’ˆå…ˆèµ°kæ­¥ï¼Œåœ¨åˆ©ç”¨ä¸Šé¢˜å¯»æ‰¾ä¸­ç‚¹æ€è·¯å³å¯è§£å†³ã€‚**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getKthFromEnd(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        slow = head
        fast = head
        #å…ˆè®©å¿«æŒ‡é’ˆfastå‘å‰èµ°kæ­¥
        for i in range(k):
            fast = fast.next
        #while(fast != None and fast.next != None)å¤šåŠ ä¸€ä¸ªfastçš„nextçš„ç»“æœä¸º[3,4,5]ä¸åŸé¢˜ç»“æœä¸ç¬¦åˆ;æ³¨æ„æ¡ä»¶æ§åˆ¶
        while(fast != None):
            slow = slow.next
            fast = fast.next
        return slow
```

#### åˆ¤æ–­å•é“¾è¡¨æ˜¯å¦åŒ…å«ç¯å¹¶æ‰¾å‡ºç¯èµ·ç‚¹

ç»å…¸é—®é¢˜çš„è§£å†³æ–¹æ¡ˆä»ç„¶æ˜¯ï¼šå¿«æ…¢æŒ‡é’ˆã€‚æ¯å½“æ…¢æŒ‡é’ˆ `slow` å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ `fast` å°±å‰è¿›ä¸¤æ­¥ã€‚

å¦‚æœ `fast` æœ€ç»ˆé‡åˆ°ç©ºæŒ‡é’ˆï¼Œè¯´æ˜é“¾è¡¨ä¸­æ²¡æœ‰ç¯ï¼›å¦‚æœ `fast` æœ€ç»ˆå’Œ `slow` ç›¸é‡ï¼Œé‚£è‚¯å®šæ˜¯ `fast` è¶…è¿‡äº† `slow` ä¸€åœˆï¼Œè¯´æ˜é“¾è¡¨ä¸­å«æœ‰ç¯ã€‚åªéœ€è¦æŠŠå¯»æ‰¾é“¾è¡¨ä¸­ç‚¹çš„ä»£ç ç¨åŠ ä¿®æ”¹å°±è¡Œäº†ï¼š

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        slow = head
        fast = head
        #å¯»æ‰¾ä¸­ç‚¹çš„å¥—è·¯
        while(fast != None and fast.next != None):
            #å¿«æŒ‡é’ˆå‰è¿›ä¸¤æ­¥
            fast = head.next.next
            #æ…¢æŒ‡é’ˆå‰è¿›ä¸€æ­¥
            slow = head.next
            #å½“å¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆå¤šèµ°ä¸€åœˆæ—¶ï¼Œç›¸é‡ä¾¿æˆç¯
            if(fast == slow):
                return True
        return False
#ä¸çŸ¥é“ä¸ºå•¥è¿™ä¸ªä»£ç æ€»æ˜¯è¿è¡Œè¶…æ—¶ï¼Œæ˜¯æ—¶é—´å¤æ‚åº¦å¤ªå¤§å—ï¼Ÿ-2022.06.21
```

#### åˆ¤æ–­ä¸¤ä¸ªå•é“¾è¡¨æ˜¯å¦ç›¸äº¤å¹¶æ‰¾å‡ºäº¤ç‚¹

å¦‚æœç”¨ä¸¤ä¸ªæŒ‡é’ˆ `p1` å’Œ `p2` åˆ†åˆ«åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šå‰è¿›ï¼Œå¹¶ä¸èƒ½**åŒæ—¶**èµ°åˆ°å…¬å…±èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ— æ³•å¾—åˆ°ç›¸äº¤èŠ‚ç‚¹ `c1`ã€‚

**è§£å†³è¿™ä¸ªé—®é¢˜çš„å…³é”®æ˜¯ï¼Œé€šè¿‡æŸäº›æ–¹å¼ï¼Œè®© `p1` å’Œ `p2` èƒ½å¤ŸåŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ `c1`**ã€‚

æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥è®© `p1` éå†å®Œé“¾è¡¨ `A` ä¹‹åå¼€å§‹éå†é“¾è¡¨ `B`ï¼Œè®© `p2` éå†å®Œé“¾è¡¨ `B` ä¹‹åå¼€å§‹éå†é“¾è¡¨ `A`ï¼Œè¿™æ ·ç›¸å½“äºã€Œé€»è¾‘ä¸Šã€ä¸¤æ¡é“¾è¡¨æ¥åœ¨äº†ä¸€èµ·ã€‚

å¦‚æœè¿™æ ·è¿›è¡Œæ‹¼æ¥ï¼Œå°±å¯ä»¥è®© `p1` å’Œ `p2` åŒæ—¶è¿›å…¥å…¬å…±éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯åŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ `c1`

```Python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        p1 = headA
        p2 = headB
        while(p1 != p2):
            #p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if(p1 == None):
                p1 = headB
            else:
                p1 = p1.next
            #p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if(p2 == None):
                p2 = headA
            else:
                p2 = p2.next
        return p1
```

## æ»‘åŠ¨çª—å£

åŒæŒ‡é’ˆè¿ç”¨æœ€éš¾å¾—éƒ¨åˆ†ï¼

|                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) |  ğŸŸ    |
| [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/) | [438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) |  ğŸŸ    |
| [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/) | [567. å­—ç¬¦ä¸²çš„æ’åˆ—](https://leetcode.cn/problems/permutation-in-string/) |  ğŸŸ    |
| [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/) | [76. æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/) |  ğŸ”´   |
|                              -                               | [å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/) |  ğŸŸ    |
|                              -                               | [å‰‘æŒ‡ Offer II 014. å­—ç¬¦ä¸²ä¸­çš„å˜ä½è¯](https://leetcode.cn/problems/MPnaiL/) |  ğŸŸ    |
|                              -                               | [å‰‘æŒ‡ Offer II 015. å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å˜ä½è¯](https://leetcode.cn/problems/VabMRr/) |  ğŸŸ    |
|                              -                               | [å‰‘æŒ‡ Offer II 016. ä¸å«é‡å¤å­—ç¬¦çš„æœ€é•¿å­å­—ç¬¦ä¸²](https://leetcode.cn/problems/wtcaE1/) |  ğŸŸ    |
|                              -                               | [å‰‘æŒ‡ Offer II 017. å«æœ‰æ‰€æœ‰å­—ç¬¦çš„æœ€çŸ­å­—ç¬¦ä¸²](https://leetcode.cn/problems/M1oyTv/) |  ğŸ”´   |

é¢˜ç›®ç‰¹ç‚¹ï¼š

**æœ€é•¿/æœ€çŸ­->å­æ•°ç»„ã€å­åºåˆ—ã€å­ä¸²**

è§£å†³ä¸€ç±»æœ€éš¾æŒæ¡çš„åŒæŒ‡é’ˆæŠ€å·§ï¼š**æ»‘åŠ¨çª—å£æŠ€å·§**ï¼›è¿™ä¸ªç®—æ³•æŠ€å·§çš„æ€è·¯éå¸¸ç®€å•ï¼Œå°±æ˜¯ç»´æŠ¤ä¸€ä¸ªçª—å£ï¼Œä¸æ–­æ»‘åŠ¨ï¼Œç„¶åæ›´æ–°ç­”æ¡ˆã€‚

è¿™ä¸ªç®—æ³•æŠ€å·§çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)ï¼Œæ¯”å­—ç¬¦ä¸²æš´åŠ›ç®—æ³•è¦é«˜æ•ˆå¾—å¤šã€‚

å…¶å®å›°æ‰°å¤§å®¶çš„ï¼Œä¸æ˜¯ç®—æ³•çš„æ€è·¯ï¼Œè€Œæ˜¯å„ç§ç»†èŠ‚é—®é¢˜ã€‚æ¯”å¦‚è¯´å¦‚ä½•å‘çª—å£ä¸­æ·»åŠ æ–°å…ƒç´ ï¼Œå¦‚ä½•ç¼©å°çª—å£ï¼Œåœ¨çª—å£æ»‘åŠ¨çš„å“ªä¸ªé˜¶æ®µæ›´æ–°ç»“æœã€‚å³ä¾¿ä½ æ˜ç™½äº†è¿™äº›ç»†èŠ‚ï¼Œä¹Ÿå®¹æ˜“å‡º bugï¼Œæ‰¾ bug è¿˜ä¸çŸ¥é“æ€ä¹ˆæ‰¾ï¼ŒçœŸçš„æŒºè®©äººå¿ƒçƒ¦çš„ã€‚

æ¡†æ¶ï¼š

```java
/* æ»‘åŠ¨çª—å£ç®—æ³•æ¡†æ¶ */
void slidingWindow(string s) {
    unordered_map<char, int> window;
    
    int left = 0, right = 0;
    while (right < s.size()) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        char c = s[right];
        // å¢å¤§çª—å£
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        ...

        /*** debug è¾“å‡ºçš„ä½ç½® ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (window needs shrink) {
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            char d = s[left];
            // ç¼©å°çª—å£
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            ...
        }
    }
}
```

**å…¶ä¸­ä¸¤å¤„ `...` è¡¨ç¤ºçš„æ›´æ–°çª—å£æ•°æ®çš„åœ°æ–¹ï¼Œåˆ°æ—¶å€™ä½ ç›´æ¥å¾€é‡Œé¢å¡«å°±è¡Œäº†**ï¼›è€Œä¸”ï¼Œè¿™ä¸¤ä¸ª `...` å¤„çš„æ“ä½œåˆ†åˆ«æ˜¯æ‰©å¤§å’Œç¼©å°çª—å£çš„æ›´æ–°æ“ä½œã€‚

åœ¨å¤„ç†å­—ç¬¦ä¸²åé¢ï¼Œc/c++è¦æ¯”Javaæœ‰ä¼˜åŠ¿ã€‚

**æ»‘åŠ¨çª—å£ç®—æ³•çš„æ€è·¯**ï¼š

1ã€æˆ‘ä»¬åœ¨å­—ç¬¦ä¸² `S` ä¸­ä½¿ç”¨åŒæŒ‡é’ˆä¸­çš„å·¦å³æŒ‡é’ˆæŠ€å·§ï¼Œåˆå§‹åŒ– `left = right = 0`ï¼ŒæŠŠç´¢å¼•**å·¦é—­å³å¼€**åŒºé—´ `[left, right)` ç§°ä¸ºä¸€ä¸ªã€Œçª—å£ã€ã€‚

PSï¼šç†è®ºä¸Šä½ å¯ä»¥è®¾è®¡ä¸¤ç«¯éƒ½å¼€æˆ–è€…ä¸¤ç«¯éƒ½é—­çš„åŒºé—´ï¼Œä½†è®¾è®¡ä¸ºå·¦é—­å³å¼€åŒºé—´æ˜¯**æœ€æ–¹ä¾¿å¤„ç†**çš„ã€‚å› ä¸ºè¿™æ ·åˆå§‹åŒ– `left = right = 0` æ—¶åŒºé—´ `[0, 0)` ä¸­æ²¡æœ‰å…ƒç´ ï¼Œä½†åªè¦è®© `right` å‘å³ç§»åŠ¨ï¼ˆæ‰©å¤§ï¼‰ä¸€ä½ï¼ŒåŒºé—´ `[0, 1)` å°±åŒ…å«ä¸€ä¸ªå…ƒç´  `0` äº†ã€‚å¦‚æœä½ è®¾ç½®ä¸ºä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ï¼Œé‚£ä¹ˆè®© `right` å‘å³ç§»åŠ¨ä¸€ä½åå¼€åŒºé—´ `(0, 1)` ä»ç„¶æ²¡æœ‰å…ƒç´ ï¼›å¦‚æœä½ è®¾ç½®ä¸ºä¸¤ç«¯éƒ½é—­çš„åŒºé—´ï¼Œé‚£ä¹ˆåˆå§‹åŒºé—´ `[0, 0]` å°±åŒ…å«äº†ä¸€ä¸ªå…ƒç´ ã€‚è¿™ä¸¤ç§æƒ…å†µéƒ½ä¼šç»™è¾¹ç•Œå¤„ç†å¸¦æ¥ä¸å¿…è¦çš„éº»çƒ¦ã€‚

2ã€æˆ‘ä»¬å…ˆä¸æ–­åœ°å¢åŠ  `right` æŒ‡é’ˆæ‰©å¤§çª—å£ `[left, right)`ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ç¬¦åˆè¦æ±‚ï¼ˆåŒ…å«äº† `T` ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼‰ã€‚

3ã€æ­¤æ—¶ï¼Œæˆ‘ä»¬åœæ­¢å¢åŠ  `right`ï¼Œè½¬è€Œä¸æ–­å¢åŠ  `left` æŒ‡é’ˆç¼©å°çª—å£ `[left, right)`ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ä¸å†ç¬¦åˆè¦æ±‚ï¼ˆä¸åŒ…å« `T` ä¸­çš„æ‰€æœ‰å­—ç¬¦äº†ï¼‰ã€‚åŒæ—¶ï¼Œæ¯æ¬¡å¢åŠ  `left`ï¼Œæˆ‘ä»¬éƒ½è¦æ›´æ–°ä¸€è½®ç»“æœã€‚

4ã€é‡å¤ç¬¬ 2 å’Œç¬¬ 3 æ­¥ï¼Œç›´åˆ° `right` åˆ°è¾¾å­—ç¬¦ä¸² `S` çš„å°½å¤´ã€‚

è¿™ä¸ªæ€è·¯å…¶å®ä¹Ÿä¸éš¾ï¼Œ**ç¬¬ 2 æ­¥ç›¸å½“äºåœ¨å¯»æ‰¾ä¸€ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œç„¶åç¬¬ 3 æ­¥åœ¨ä¼˜åŒ–è¿™ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œæœ€ç»ˆæ‰¾åˆ°æœ€ä¼˜è§£**ï¼Œä¹Ÿå°±æ˜¯æœ€çŸ­çš„è¦†ç›–å­ä¸²ã€‚å·¦å³æŒ‡é’ˆè½®æµå‰è¿›ï¼Œçª—å£å¤§å°å¢å¢å‡å‡ï¼Œçª—å£ä¸æ–­å‘å³æ»‘åŠ¨ï¼Œè¿™å°±æ˜¯ã€Œæ»‘åŠ¨çª—å£ã€è¿™ä¸ªåå­—çš„æ¥å†ã€‚

#### é•¿åº¦æœ€å°å­æ•°ç»„

ç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚

æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶å’Œ â‰¥ target çš„é•¿åº¦æœ€å°çš„ è¿ç»­å­æ•°ç»„ [numsl, numsl+1, ..., numsr-1, numsr] ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 

```python
class Solution(object):
    def minSubArrayLen(self, target, nums):
        """
        :type target: int
        :type nums: List[int]
        :rtype: int
        """
        #åˆ¤æ–­æç«¯æƒ…å†µ
        if len(nums) == 0:
            return 0
        #ç¡®å®šæœ€å€¼
        res = len(nums) + 1
        s = 0
        #å®šä¹‰åŒæŒ‡é’ˆ
        right = left = 0
        #æ‰©å¤§çª—å£
        while(right < len(nums)):
            s = s + nums[right]
            right += 1
            #æ¯”è¾ƒç›®æ ‡å€¼ï¼Œæ‰©å¤§çª—å£çš„ç»ˆæ­¢æ¡ä»¶
            while s >= target:
                #righ-leftä¸ºçª—å£å†…çš„å…ƒç´ 
                res = min(res,right-left)
                #ä»å·¦ä¾§ç¼©å°çª—å£
                s = s - nums[left]
                left += 1
        #æ‰€æœ‰å…ƒç´ çš„å’Œå°äºtarget
        if res == len(nums)+1:
            return 0
        #ç¬¦åˆæ¡ä»¶è¾“å‡º
        else:
            return res
```

#### æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        #æç«¯æ¡ä»¶åˆ¤æ–­
        if len(s) == 0:
            return 0
        #å®šä¹‰æ‰€éœ€å˜é‡
        left = count = res = 0
        #éå†åˆ—è¡¨çš„æ—¶é—´å¤æ‚åº¦æ˜¯Oï¼ˆnï¼‰ï¼Œéå†é›†åˆçš„æ—¶é—´å¤æ‚åº¦æ˜¯Oï¼ˆ1ï¼‰
        windows = set()
        #æœ‰æŒ‡é’ˆä¾æ¬¡å‘åéå†
        for i in range(len(s)):
            #è®¡æ•°
            count += 1
            #å³æŒ‡é’ˆæŒ‡å‘å…ƒç´ å·²ç»åœ¨çª—å£ä¸­ï¼Œå³å‡ºç°é‡å¤å…ƒç´ 
            while s[i] in windows:
                #ç¼©å°çª—å£
                windows.remove(s[left])
                count -= 1
                left += 1
            #ä¿ç•™æœ€å€¼
            res = max(res,count)
            #çª—å£å³ä¾§åŠ å…¥å…ƒç´ 
            windows.add(s[i])
        #è¿”å›ç»“æœ
        return res
```

#### ä¹˜ç§¯å°äºKçš„å­æ•°ç»„

```python
class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        #ç‰¹æ®Šæƒ…å†µ
        if k <= 1:
            return 0
        #åŒæŒ‡é’ˆ
        left = 0
        right = 0
        #è®°å½•å™¨ä¸è®¡æ•°å™¨
        res = 1
        result = 0
        #æ‰©å¤§çª—å£
        while right < len(nums):
            res *= nums[right]
            #ç¼©å°çª—å£
            while res >= k:
                res /= nums[left]
                left += 1
            result += (right-left+1)
            right += 1
        return result
```

#### æœ€å¤§è¿ç»­1çš„ä¸ªæ•°

```Python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        #è®¾ç½®åŒæŒ‡é’ˆ
        left = 0
        right = 0
        #è®°å½•å™¨å’Œè®¡æ•°å™¨
        res = 0
        count = 0
        while right < len(nums):
            #æ‰©å¤§çª—å£
            if nums[right] == 0:
                count += 1
            right += 1
            #ç¼©å°çª—å£
            if count > k:
                if nums[left] == 0:
                    count -= 1
                left += 1
            res = max(res,right - left)
        return res
```



## äºŒå‰æ ‘

è§†é¢‘å¯¼å­¦ï¼š

[äºŒå‰æ ‘/é€’å½’çš„æ¡†æ¶æ€ç»´ï¼ˆçº²é¢†ç¯‡ï¼‰](https://www.bilibili.com/video/BV1nG411x77H?spm_id_from=333.337.search-card.all.click&vd_source=f093c3d64ba399e149cbffa6cd31a7b0)

**äºŒå‰æ ‘é¢˜ç›®çš„é€’å½’è§£æ³•å¯ä»¥åˆ†ä¸¤ç±»æ€è·¯ï¼Œç¬¬ä¸€ç±»æ˜¯éå†ä¸€éäºŒå‰æ ‘å¾—å‡ºç­”æ¡ˆï¼Œç¬¬äºŒç±»æ˜¯é€šè¿‡åˆ†è§£é—®é¢˜è®¡ç®—å‡ºç­”æ¡ˆï¼Œè¿™ä¸¤ç±»æ€è·¯åˆ†åˆ«å¯¹åº”ç€ [å›æº¯ç®—æ³•æ ¸å¿ƒæ¡†æ¶](https://labuladong.gitee.io/algo/4/30/104/) å’Œ [åŠ¨æ€è§„åˆ’æ ¸å¿ƒæ¡†æ¶](https://labuladong.gitee.io/algo/3/24/67/)**ã€‚äºŒå‰æ ‘æ¨¡å‹å‡ ä¹æ˜¯æ‰€æœ‰é«˜çº§ç®—æ³•çš„åŸºç¡€ï¼Œå°¤å…¶æ˜¯é‚£ä¹ˆå¤šäººè¯´å¯¹é€’å½’çš„ç†è§£ä¸åˆ°ä½ï¼Œæ›´åº”è¯¥å¥½å¥½åˆ·äºŒå‰æ ‘ç›¸å…³é¢˜ç›®ã€‚

2022.08.28æ·»åŠ ï¼šå¯¹äºé€’å½’å‡½æ•°ä¹¦å†™çš„ä¸€äº›**æ–°çš„æ€è€ƒä¸å¯å‘**

å­¦ä¹ æœ¬éƒ¨åˆ†ä¸»è¦æ˜¯å­¦ä¼šä½¿ç”¨é€’å½’å‡½æ•°çš„ä¹¦å†™é€»è¾‘ï¼š

å†æ¬¡æ¸©ä¹ ä¸€ä¸‹ä¹‹å‰å­¦è¿‡çš„**é€’å½’ä¸‰éƒ¨æ›²**ï¼š

1.é€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼çš„è®¾ç½®

æ¯”å¦‚åœ¨åœ¨å†™å›æº¯å‡½æ•°æ—¶ï¼Œå‡½æ•°å‚æ•°éœ€è¦è‡ªå·±å»å®šä¹‰ã€‚æ­¤æ—¶å°±è¦è€ƒè™‘ï¼Œé‚£äº›å‚æ•°æ˜¯æˆ‘éœ€è¦çš„ï¼Œé‚£äº›å‚æ•°æ˜¯é¢˜ç›®ä¸­å·²çŸ¥çš„ï¼›è‡ªå®šä¹‰çš„è¿™ä¸ªå‡½æ•°çš„ç±»å‹æ˜¯ä»€ä¹ˆï¼šviodæ³›å‹ï¼Ÿboolå‹ï¼Ÿintå‹ï¼Ÿ

```c++
void traverse(å‚æ•°1ï¼Œå‚æ•°2....){
    
}
```

2.ç»ˆæ­¢æ¡ä»¶

å¤šæ•°æƒ…å†µä¸‹å°±æ˜¯éå†åˆ°æ ‘çš„æ ¹èŠ‚ç‚¹åå¼€å§‹è¿”å›ï¼›

```c++
if(rooot == NULL){
	return;
}
```

3.é€’å½’çš„é€»è¾‘

åœ¨ç»ˆæ­¢æ¡ä»¶ä¹‹åç´§æ¥ç€å°±æ˜¯é€’å½’å‡½æ•°çš„è°ƒç”¨ï¼›ç»å¤§å¤šæ•°é€’å½’çš„é€»è¾‘æ˜¯å‰åºé€»è¾‘ï¼Œé¢˜ç›®è®©å¹²å•¥å’±å°±å¹²å•¥ï¼Œè€Œä¸”é€’å½’çš„é¡ºåºä¸€èˆ¬å°±æ˜¯å…ˆå·¦å­æ ‘åå³å­æ ‘ï¼Œä»ä¸Šåˆ°ä¸‹çš„DFSã€‚

```c++
//å‰åºæ“ä½œï¼ˆçœ‹é¢˜ç›®è¦æ±‚ï¼‰
traverse(root->left,....);
traverse(root->right,....);
```

å¯¹äºå¤§å¤šæ•°çš„ç®—æ³•ï¼Œæš´åŠ›è§£å†³æ˜¯å¯ä»¥çš„ï¼›ä½†æ˜¯æ— æ•°ä¸ªforå¾ªç¯åµŒå¥—æ—¢æµªè´¹æ—¶é—´åˆæµªè´¹ç©ºé—´ï¼Œå½“æƒ…å†µè¾ƒå¤æ‚æ˜¯ï¼Œforå¾ªç¯åµŒå¥—å¿…å®šä¼šå‡ºé”™ã€‚è€Œé€’å½’å›æº¯å‡½æ•°çš„ä¹¦å†™ï¼Œå°±æ˜¯è®©è®¡ç®—æœºè‡ªå·±å»æ·±å¤„éå†è¿­ä»£ï¼Œç©ºé—´æ—¶é—´éƒ½å¯èŠ‚çœï¼Œå¯è°“æ˜¯è®¡ç®—æœºæ€ç»´çš„ç²¾é«“ä¹‹å¤„ã€‚

æ ‘æ—¢æœ‰é€’å½’éå†åˆæœ‰è¿­ä»£éå†ï¼Œåœ¨è¿­ä»£éå†æ—¶ä¸€å®šè¦æ³¨æ„whileå¾ªç¯çš„ç»ˆæ­¢æ¡ä»¶ï¼Œä¸€èˆ¬æ˜¯å½“èŠ‚ç‚¹ä¸ä¸ºç©ºæ—¶ï¼Œç»ˆæ­¢å¾ªç¯whileï¼›å³ï¼š**while(!=root)**

### äºŒå‰æ ‘-çº²é¢†ç¯‡

|                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) |  ğŸŸ¢   |
| [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) | [144. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode.cn/problems/binary-tree-preorder-traversal/) |  ğŸŸ¢   |
| [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) | [543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode.cn/problems/diameter-of-binary-tree/) |  ğŸŸ¢   |
|                              -                               | [å‰‘æŒ‡ Offer 55 - I. äºŒå‰æ ‘çš„æ·±åº¦](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/) |  ğŸŸ¢   |

æ€»çš„è€è¯´ï¼ŒäºŒå‰æ ‘çš„ä¸¤ç§è§£å†³æ€è·¯ï¼š
1.éå†->å›æº¯é—®é¢˜->å‰åºæ“ä½œ
2.åˆ†è§£->åŠ¨è§„é—®é¢˜->ååºæ“ä½œ

é‡åˆ°ä¸€é“äºŒå‰æ ‘çš„é¢˜ç›®æ—¶çš„é€šç”¨æ€è€ƒè¿‡ç¨‹æ˜¯ï¼š

**1ã€æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆ**ï¼Ÿå¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ª `traverse` å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ã€‚

**2ã€æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆ**ï¼Ÿå¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ã€‚

**3ã€æ— è®ºä½¿ç”¨å“ªä¸€ç§æ€ç»´æ¨¡å¼ï¼Œä½ éƒ½è¦æ˜ç™½äºŒå‰æ ‘çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšä»€ä¹ˆï¼Œéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰ä¸­ååºï¼‰åš**ã€‚

äºŒå‰æ ‘çš„æ¡†æ¶æ€ç»´ï¼š

```Java
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // å‰åºä½ç½®
    traverse(root.left);
    // ä¸­åºä½ç½®
    traverse(root.right);
    // ååºä½ç½®
```

ä»¥æ•°ç»„å’Œé“¾è¡¨ä¸ºä¾‹ï¼Œçœ‹éå†å’Œåˆ†è§£çš„åŒºåˆ«ä¸è”ç³»ï¼š

```python
/* è¿­ä»£éå†æ•°ç»„ */
#void traverse(int[] arr) {
    #for (int i = 0; i < arr.length; i++) {

    #}
#}
def traverse(int[] arr):
	for i in range(len(arr)):
	

/* é€’å½’éå†æ•°ç»„ */
#void traverse(int[] arr, int i) {
    #if (i == arr.length) {
        #return;
    #}
    #// å‰åºä½ç½®
    #traverse(arr, i + 1);
    #// ååºä½ç½®
#}
def traverse(int[] arr, int i):
	if (i == len(arr)):
		return
		
	// å‰åºä½ç½®
    traverse(arr, i + 1);
    // ååºä½ç½®

/* è¿­ä»£éå†å•é“¾è¡¨ */
#void traverse(ListNode head) {
    #for (ListNode p = head; p != null; p = p.next) {

    #}
#}
def traverse(ListNode head):
	p = head
	while(p != None and p.next != None):
		p = p.next

/* é€’å½’éå†å•é“¾è¡¨ */
#void traverse(ListNode head) {
    #if (head == null) {
        #return;
    #}
    #// å‰åºä½ç½®
    #traverse(head.next);
    #// ååºä½ç½®
#}
def traverse(ListNode head):
	if (head == None):
		return
		
	// å‰åºä½ç½®
    traverse(head.next);
    // ååºä½ç½®
```

é€’å½’ä¸‰éƒ¨æ›²ï¼š

é€’å½’å‡½æ•°çš„å‚æ•°è¿”å›å€¼

ç»ˆæ­¢æ¡ä»¶

é€’å½’çš„é€»è¾‘

#### äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        #åˆ†è§£é—®é¢˜ï¼šå…ˆæ‰¾å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ç„¶ååŠ ä¸€-åŠ¨æ€è§„åˆ’æ€è·¯(ååºä½ç½®æ“ä½œ)
        #é€’å½’åˆ°æ ¹èŠ‚ç‚¹
        if(root == None):
            return 0
        
        leftmax = self.maxDepth(root.left)
        rightmax = self.maxDepth(root.right)
        #æ¨åˆ°åŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        return max(leftmax,rightmax) + 1
```

```java
#å›æº¯æ€è·¯
    class Solution {

    int depth = 0;
    int res = 0;

    public int maxDepth(TreeNode root) {
        traverse(root);
        return res;
    }

    // éå†äºŒå‰æ ‘
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        // å‰åºéå†ä½ç½®
        depth++;
        // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // ååºéå†ä½ç½®
        depth--;
    }
}
```

#### äºŒå‰æ ‘æœ€å°æ·±åº¦

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        if not root.left and not root.right:
            return 1

        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth) # è·å¾—å·¦å­æ ‘çš„æœ€å°é«˜åº¦
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth) # è·å¾—å³å­æ ‘çš„æœ€å°é«˜åº¦
        return min_depth + 1
```

#### äºŒå‰æ ‘çš„éå†

##### å‰åºéå†

é€’å½’è§£æ³•

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
#é€’å½’è§£æ³•
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def preorder(root: TreeNode):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)
        
        res = list()
        preorder(root)
        return res
  
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #ä¿å­˜ç»“æœ
        res = []

        #å®šä¹‰éå†å‡½æ•°
        def traversal(root):
            #æ ¹èŠ‚ç‚¹åˆ¤æ–­
            if root == None:
                return
            res.append(root.val)
            traversal(root.left)
            traversal(root.right)
        
        traversal(root)
        return res
```

è¿­ä»£è§£æ³•

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        if not root:
            return res
        
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res
```

##### ä¸­åºéå†

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #ä¿å­˜ç»“æœ
        res = []

        def traervsal(root):
            #æ ¹èŠ‚ç‚¹åˆ¤æ–­
            if root == None:
                return
            #é€’å½’éå†
            traervsal(root.left)
            #ä¸­åºæ“ä½œ
            res.append(root.val)
            traervsal(root.right)
        traervsal(root)
        return res
```

##### ååºéå†

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #ä¿å­˜ç»“æœ
        res = []

        #å®šä¹‰éå†å‡½æ•°
        def traversal(root):
            if root == None:
                return
            traversal(root.left)
            traversal(root.right)
            #ååºæ“ä½œ
            res.append(root.val)
        traversal(root)
        return res
```

#### äºŒå‰æ ‘çš„æœ€å¤§ç›´å¾„

ååºéå†

```python
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1
        def depth(node):
            # è®¿é—®åˆ°ç©ºèŠ‚ç‚¹äº†ï¼Œè¿”å›0
            if not node:
                return 0
            # å·¦å­©å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
            L = depth(node.left)
            # å³å­©å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
            R = depth(node.right)
            # è®¡ç®—d_nodeå³L+R+1 å¹¶æ›´æ–°ans
            self.ans = max(self.ans, L + R + 1)
            # è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
            return max(L, R) + 1

        depth(root)
        return self.ans - 1
```

#### äºŒå‰æ ‘çš„å±‚åºéå†

å±‚åºéå†å°±æ˜¯ä»å·¦åˆ°å³ä¸€å±‚ä¸€å±‚å»éå†äºŒå‰æ ‘ã€‚éœ€è¦å€Ÿç”¨ä¸€ä¸ªè¾…åŠ©æ•°æ®ç»“æ„å³é˜Ÿåˆ—æ¥å®ç°ï¼Œ**é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºï¼Œç¬¦åˆä¸€å±‚ä¸€å±‚éå†çš„é€»è¾‘ï¼Œè€Œæ˜¯ç”¨æ ˆå…ˆè¿›åå‡ºé€‚åˆæ¨¡æ‹Ÿæ·±åº¦ä¼˜å…ˆéå†ä¹Ÿå°±æ˜¯é€’å½’çš„é€»è¾‘ã€‚è€Œè¿™ç§å±‚åºéå†æ–¹å¼å°±æ˜¯å›¾è®ºä¸­çš„å¹¿åº¦ä¼˜å…ˆéå†ï¼Œåªä¸è¿‡æˆ‘ä»¬åº”ç”¨åœ¨äºŒå‰æ ‘ä¸Š**[[1]](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)

##### å±‚åºéå†

```python
#å±‚åºéå†è¿­ä»£æ³•ï¼š
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        results = []
        if not root:
            return results
        
        from collections import deque
        que = deque([root])
        
        while que:
            size = len(que)
            result = []
            for _ in range(size):
                cur = que.popleft()
                result.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            results.append(result)

        return results
    
  
#å±‚åºéå†é€’å½’æ³•
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        res = []
        def cengxu(root,depth):
            if not root:
                return []
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            if root.left:
                cengxu(root.left,depth+1)
            if root.right:
                cengxu(root.right,depth+1)
        cengxu(root,0)
        return res
   
#[[3],[9,20],[15,7]]æœ€åçš„ç»“æœæ˜¯åˆ—è¡¨çš„åµŒå¥—

#è‡ªåº•å‘ä¸Šå±‚åºéå†
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        #è®°å½•ç»“æœ
        res = []
        #å®šä¹‰å±‚åºéå†å‡½æ•°
        def cengxu(root,depth):
            #æ ¹èŠ‚ç‚¹åˆ¤æ–­
            if not root:
                return None
            #ä¸€å¼€å§‹å¾ˆä¸ç†è§£è¿™ä¸€æ­¥
            #è§‚å¯Ÿç»“æœ:[[15,7],[9,20],[3]]ï¼›æ¶‰åŠåˆ°åˆ—è¡¨çš„åµŒå¥—
            #æ¯å½“æ·±åº¦åŠ ä¸€,å°±è¦å¢åŠ ä¸€ä¸ªå­åˆ—è¡¨
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            if root.left:
                cengxu(root.left,depth + 1)
            if root.right:
                cengxu(root.right,depth + 1)
        cengxu(root,0)
        return res[::-1]
```

##### äºŒå‰æ ‘çš„å³è§†å›¾

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #ç»“æœè®°å½•
        res = []
        #å®šä¹‰å±‚åºéå†å‡½æ•°
        def cengxu(root,depth):
            if not root:
                return None
            if len(res) == depth:
                res.append(root.val)
            #res[depth].append(root.val)
            #åªå»éå†å³å­æ ‘-å‡†ç¡®æ¥è¯´æ˜¯å»éå†æ¯ä¸ªèŠ‚ç‚¹çš„å³å­æ ‘
            if root.right:
                cengxu(root.right,depth + 1)
            if root.left:
                cengxu(root.left,depth + 1)
        cengxu(root,0)
        return res
```

##### è®¡ç®—äºŒå‰æ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•°

```Python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def averageOfLevels(self, root):
        """
        :type root: TreeNode
        :rtype: List[float]
        """
        #ä¿å­˜ç»“æœ
        res = []
        ans = []
        #å®šä¹‰å±‚åºéå†å‡½æ•°
        def cengxu(root,depth):
            if not root:
                return None
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            #éå†å·¦å³å­æ ‘
            if root.left:
                cengxu(root.left,depth + 1)
            if root.right:
                cengxu(root.right,depth + 1)
        cengxu(root,0)
        for i in range(len(res)):
            sum1 = sum(res[i])
            num = len(res[i])
            ans.append(sum1 / num)
        return ans
```



### äºŒå‰æ ‘-æ€è·¯ç¯‡

å±‚åºéå†+æ ˆå°±æ˜¯ååºéå†ç»“æœ

åˆ·å®Œä¸Šé¢çº²é¢†ç¯‡å¹…çš„ä¸€äº›ä½“ä¼šï¼š

äºŒå‰æ ‘é‡è¦çš„éƒ¨åˆ†ï¼šæ¡†æ¶+ç»†èŠ‚ï¼›æ¡†æ¶ä¸»è¦æ˜¯å¯¹é€’å½’å‡½æ•°çš„ä¹¦å†™ï¼Œç»†èŠ‚å°±æ˜¯-å‰åºéå†ORååºéå†-ä»£ç çš„æ‘†æ”¾**ä½ç½®**

|                           LeetCode                           |                             åŠ›æ‰£                             | éš¾åº¦ |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [114. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) | [114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) |  ğŸŸ    |
| [116. Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) | [116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) |  ğŸŸ    |
| [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) | [226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/) |  ğŸŸ¢   |
|                              -                               | [å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/) |  ğŸŸ¢   |

#### åè½¬äºŒå‰æ ‘

åè½¬çš„æ€æƒ³å°±æ˜¯å€ŸåŠ©tmpæŒ‡é’ˆè¿›è¡Œå·¦å³èŠ‚ç‚¹çš„äº¤æ¢

åˆ†è§£é—®é¢˜æ€è·¯ï¼š

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        #åˆ¤æ–­æ ¹èŠ‚ç‚¹
        if root == None:
            return
            
        #åˆ†è§£é—®é¢˜çš„æ€è·¯
        self.invertTree(root.left)
        self.invertTree(root.right)

        tmp = root.left
        root.left = root.right
        root.right = tmp
        return root
```

å›æº¯æ€è·¯ï¼š

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        self.traverse(root)
        return root
        
    def traverse(self, root):
        if root == None:
            return
        #å‰åºä½ç½®
        tmp = root.left
        root.left = root.right
        root.right = tmp
        #éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
        self.traverse(root.left)
        self.traverse(root.right)
```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        /*
        //ç»ˆæ­¢èŠ‚ç‚¹åˆ¤æ–­
        //ä»ä¸Šåˆ°ä¸‹é€’å½’éå†
        if(root == NULL) return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
        */
        //è¿­ä»£éå†
        if(root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            swap(node->left,node->right);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);

        }
        return root;

    }
};
```

#### å¯¹ç§°äºŒå‰æ ‘

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        return self.compare(root.left, root.right)
        
    def compare(self, left, right):
        #å¯¹ç§°äºŒå‰æ ‘çš„æ¡ä»¶
        if left != None and right == None:
            return False
        elif left == None and right != None:
            return False
        elif left == None and right == None:
            return True
        elif left.val != right.val:
            return False
        #æ­¤æ—¶å°±æ˜¯å·¦å³èŠ‚ç‚¹ç›¸åŒè¿›å…¥ä¸‹ä¸€å±‚éå†
        ots = self.compare(left.left,right.right)
        ins = self.compare(left.right,right.left)
        isSymmetric = ots and ins
        return isSymmetric
```

#### å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

å‰åºéå†ï¼š

å‰åºéå†æ—¶è¦å®šä¹‰ä¸€ä¸ªtraverseå‡½æ•°ç”¨äºé€’å½’å‰åºèŠ‚ç‚¹ã€‚

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution(object):
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        #æ ¹èŠ‚ç‚¹æƒ…å†µ
        if root == None:
            return
        self.traverse(root.left,root.right)
        return root
    def traverse(self,node1,node2):
        if node1 == None and node2 == None:
            return
        #è¿æ¥ä¼ å…¥çš„ä¸¤ä¸ªèŠ‚ç‚¹
        node1.next = node2
        #å‰åºéå†
        self.traverse(node1.left,node1.right)
        self.traverse(node2.left,node2.right)
        self.traverse(node1.right,node2.left)
```

#### å°†äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

é¦–å…ˆé€šè¿‡éå†å¯»æ±‚è§£é¢˜æ€è·¯ï¼šå‘ç°éå†è™½ç„¶å¾—åˆ°äº†å‰åºéå†ç»“æœä½†æ˜¯æ— æ³•æŠŠåŸæ¥çš„äºŒå‰æ ‘æ‹‰å¹³ä¸ºä¸€ä¸ªé“¾è¡¨

å› æ­¤å¯»æ±‚åˆ†è§£é—®é¢˜çš„è§£å†³æ–¹æ³•ï¼šå…ˆæ‹‰å¹³å·¦å­æ ‘ï¼Œåœ¨æ‹‰å¹³å³å­æ ‘ï¼›æœ€åå°†å³å­æ ‘å«æ¥åˆ°å·¦å­æ ‘ä¸Šå³å¯å®Œæˆã€‚

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        #æ ¹èŠ‚ç‚¹æ“ä½œ
        if root == None:
            return 
        #æ‹‰å¹³å·¦å³å­æ ‘
        self.flatten(root.left)
        self.flatten(root.right)
        #ååºæ“ä½œ:åˆ†åˆ«å°†å­æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨
        l = root.left
        r = root.right
        #å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
        root.left = None
        root.right = l
        #å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
        p = root
        while(p.right != None):
            p = p.right
        p.right = r
```

#### å·¦å¶å­ä¹‹å’Œ

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        #æ ¹èŠ‚ç‚¹åˆ¤æ–­
        if not root: 
            return 0
        
        left_left_leaves_sum = self.sumOfLeftLeaves(root.left)  # å·¦
        right_left_leaves_sum = self.sumOfLeftLeaves(root.right) # å³
        
        cur_val = 0
        if root.left and not root.left.left and not root.left.right: 
            cur_val = root.left.val  # ä¸­
            
        return cur_val + left_left_leaves_sum + right_left_leaves_sum
```



### äºŒå‰æ ‘-æ„é€ ç¯‡

æ¯æ—¥ä¸€éè§£é¢˜æ€è·¯ï¼š

äºŒå‰æ ‘è§£é¢˜çš„æ€ç»´æ¨¡å¼åˆ†ä¸¤ç±»ï¼š

**1ã€æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆ**ï¼Ÿå¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ª `traverse` å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ï¼Œè¿™å«ã€Œéå†ã€çš„æ€ç»´æ¨¡å¼ã€‚

**2ã€æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆ**ï¼Ÿå¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™å«ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€ç»´æ¨¡å¼ã€‚

æ— è®ºä½¿ç”¨å“ªç§æ€ç»´æ¨¡å¼ï¼Œä½ éƒ½éœ€è¦æ€è€ƒï¼š

**å¦‚æœå•ç‹¬æŠ½å‡ºä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹ï¼Œå®ƒéœ€è¦åšä»€ä¹ˆäº‹æƒ…ï¼Ÿéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰/ä¸­/ååºä½ç½®ï¼‰åš**ï¼Ÿå…¶ä»–çš„èŠ‚ç‚¹ä¸ç”¨ä½ æ“å¿ƒï¼Œé€’å½’å‡½æ•°ä¼šå¸®ä½ åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šæ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚

**äºŒå‰æ ‘çš„æ„é€ é—®é¢˜ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯ï¼šæ„é€ æ•´æ£µæ ‘ = æ ¹èŠ‚ç‚¹ + æ„é€ å·¦å­æ ‘ + æ„é€ å³å­æ ‘**ã€‚

#### æœ€å¤§äºŒå‰æ ‘

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        #å…ˆæ‰¾åˆ°æœ€å¤§å€¼ä¸å…¶å¯¹åº”çš„ç´¢å¼• æ ¹èŠ‚ç‚¹ 
        maxvalue = max(nums)
        index = nums.index(maxvalue)
        #å°†æœ€å¤§å€¼ç¡®å®šä¸ºçˆ¶èŠ‚ç‚¹ æ ¹èŠ‚ç‚¹ 
        root = TreeNode(maxvalue)
        #å‰åºæ“ä½œåˆ’åˆ†å·¦å³å­æ ‘  æ„é€ å·¦å­æ ‘ + æ„é€ å³å­æ ‘
        left = nums[:index]
        right = nums[index + 1:]
        #é€’å½’éå†
        root.left = self.constructMaximumBinaryTree(left)
        root.right = self.constructMaximumBinaryTree(right)
        return root
```

#### é€šè¿‡å‰åºå’Œä¸­åºéå†ç»“æœæ„é€ äºŒå‰æ ‘

**æˆ‘ä»¬è‚¯å®šè¦æƒ³åŠæ³•ç¡®å®šæ ¹èŠ‚ç‚¹çš„å€¼ï¼ŒæŠŠæ ¹èŠ‚ç‚¹åšå‡ºæ¥ï¼Œç„¶åé€’å½’æ„é€ å·¦å³å­æ ‘å³å¯**ã€‚

å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœæœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼š

```Java
void traverse(TreeNode root) {
    // å‰åºéå†
    preorder.add(root.val);
    traverse(root.left);
    traverse(root.right);
}

void traverse(TreeNode root) {
    traverse(root.left);
    // ä¸­åºéå†
    inorder.add(root.val);
    traverse(root.right);
```

æ‰¾åˆ°æ ¹èŠ‚ç‚¹æ˜¯å¾ˆç®€å•çš„ï¼Œå‰åºéå†çš„ç¬¬ä¸€ä¸ªå€¼ `preorder[0]` å°±æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ã€‚

å…³é”®åœ¨äºå¦‚ä½•é€šè¿‡æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œå°† `preorder` å’Œ `postorder` æ•°ç»„åˆ’åˆ†æˆä¸¤åŠï¼Œæ„é€ æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼Ÿ

æ¢å¥è¯è¯´ï¼Œå¯¹äºä»¥ä¸‹ä»£ç ä¸­çš„ `?` éƒ¨åˆ†åº”è¯¥å¡«å…¥ä»€ä¹ˆï¼š

```java
/* ä¸»å‡½æ•° */
public TreeNode buildTree(int[] preorder, int[] inorder) {
    // æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œç”¨ preorder å’Œ inorder æ„é€ äºŒå‰æ ‘
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1);
}

/* 
    build å‡½æ•°çš„å®šä¹‰ï¼š
    è‹¥å‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
    ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
    æ„é€ äºŒå‰æ ‘ï¼Œè¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ 
*/
TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    int rootVal = preorder[preStart];
    // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }

    TreeNode root = new TreeNode(rootVal);
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = build(preorder, ?, ?,
                      inorder, ?, ?);

    root.right = build(preorder, ?, ?,
                       inorder, ?, ?);
    return root;
}
```

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        #æ ‘ä¸ºç©ºï¼Œè¿›è¡Œé€’å½’ç»ˆæ­¢
        if not preorder:
            return None
        
        #æ‰¾åˆ°å¹¶æ„é€ æ ¹èŠ‚ç‚¹
        rootval = preorder[0]
        root = TreeNode(rootval)
        #ä»ä¸­åºéå†åˆ‡å‰²
        index = inorder.index(rootval)
        inleft = inorder[:index]
        inright = inorder[index + 1:]
        #é‡ç‚¹ï¼šåˆ‡å‰²å‰åºæ•°ç»„ï¼šæ³¨æ„å­æ•°ç»„å¤§å°ä¸€å®šä¿æŒä¸å˜
        preleft = preorder[1:1+len(inleft)]
        preright = preorder[len(inleft)+1:]
        #é€’å½’
        root.left = self.buildTree(preleft,inleft)
        root.right = self.buildTree(preright,inright)
        return root
```

#### ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

```Python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        #ç‰¹æ®Šæƒ…å†µåˆ¤æ–­
        if not postorder:
            return None
        #æ‰¾åˆ°å¹¶æ„å»ºæ ¹èŠ‚ç‚¹
        rootval = postorder[-1]
        root = TreeNode(rootval)
        #ä¸­åºæ•°ç»„åœ¨ç¡®å®šä½ç½®å¹¶åˆ‡å‰²æ•°ç»„
        index = inorder.index(rootval)
        inleft = inorder[:index]
        inright = inorder[index+1:]
        #é‡ç‚¹æ˜¯ååºæ•°ç»„åˆ‡å‰²å¤§å°
        poleft = postorder[:len(inleft)]
        poright = postorder[len(inleft):len(postorder)-1]
        #é€’å½’
        root.left = self.buildTree(inleft,poleft)
        root.right = self.buildTree(inright,poright)
        return root
```

#### å®Œå…¨äºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°

```python
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        return self.getNodesNum(root)
        
    def getNodesNum(self, cur):
        if not cur:
            return 0
        leftNum = self.getNodesNum(cur.left) #å·¦
        rightNum = self.getNodesNum(cur.right) #å³
        treeNum = leftNum + rightNum + 1 #ä¸­
        return treeNum
   
#ç®€åŒ–ç‰ˆ
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```

#### å¹³è¡¡äºŒå‰æ ‘

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if self.get_height(root) != -1:
            return True
        else:
            return False
    
    def get_height(self, root: TreeNode) -> int:
        # Base Case
        if not root:
            return 0
        # å·¦
        if (left_height := self.get_height(root.left)) == -1:
            return -1
        # å³
        if (right_height := self.get_height(root.right)) == -1:
            return -1
        # ä¸­
        if abs(left_height - right_height) > 1:
            return -1
        else:
            return 1 + max(left_height, right_height)
```

#### äºŒå‰æ ‘çš„è·¯å¾„

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        path = ''
        res = []
        if not root:
            return res
        self.road(root,path,res)
        return res

    #å®šä¹‰éå†å‡½æ•° 
    def road(self,cur,path,res):
        #è·¯å¾„è¡¨ç¤º
        path += str(cur.val)
        #å¶å­ç»“ç‚¹åˆ¤æ–­
        if not cur.left and not cur.right:
            res.append(path)
        #é€’å½’å·¦å³å­æ ‘
        if cur.left:
            self.road(cur.left,path + '->',res)
        if cur.right:
            self.road(cur.right,path + '->',res)
```

#### äºŒå‰æ ‘å‡æ

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        //åˆ¤æ–­ç©ºå€¼
        if(!root){
            return nullptr;
        }
        //é€’å½’å·¦å³å­æ ‘
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        //åˆ¤æ–­æ ¹èŠ‚ç‚¹
        if(root->val == 0 && !root->left && !root->right){
            return nullptr;
        }
        return root;
    }
};
```

#### æœ€å¤§äºŒå‰æ ‘

ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ nums ã€‚ æœ€å¤§äºŒå‰æ ‘ å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» nums é€’å½’åœ°æ„å»º:

åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º nums ä¸­çš„æœ€å¤§å€¼ã€‚
é€’å½’åœ°åœ¨æœ€å¤§å€¼ å·¦è¾¹ çš„ å­æ•°ç»„å‰ç¼€ä¸Š æ„å»ºå·¦å­æ ‘ã€‚
é€’å½’åœ°åœ¨æœ€å¤§å€¼ å³è¾¹ çš„ å­æ•°ç»„åç¼€ä¸Š æ„å»ºå³å­æ ‘ã€‚
è¿”å› nums æ„å»ºçš„ æœ€å¤§äºŒå‰æ ‘ ã€‚
é“¾æ¥ï¼šhttps://leetcode.cn/problems/maximum-binary-tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* node = new TreeNode(0);
        if (nums.size() == 1) {
            node->val = nums[0];
            return node;
        }
        // æ‰¾åˆ°æ•°ç»„ä¸­æœ€å¤§çš„å€¼å’Œå¯¹åº”çš„ä¸‹è¡¨
        int maxValue = 0;
        int maxValueIndex = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }
        node->val = maxValue;
        // æœ€å¤§å€¼æ‰€åœ¨çš„ä¸‹è¡¨å·¦åŒºé—´ æ„é€ å·¦å­æ ‘
        if (maxValueIndex > 0) {
            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
            node->left = constructMaximumBinaryTree(newVec);
        }
        // æœ€å¤§å€¼æ‰€åœ¨çš„ä¸‹è¡¨å³åŒºé—´ æ„é€ å³å­æ ‘
        if (maxValueIndex < (nums.size() - 1)) {
            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = constructMaximumBinaryTree(newVec);
        }
        return node;
    }
};

//ä¼˜åŒ–éå†ä»£ç 
class Solution {
private:
    // åœ¨å·¦é—­å³å¼€åŒºé—´[left, right)ï¼Œæ„é€ äºŒå‰æ ‘
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // åˆ†å‰²ç‚¹ä¸‹è¡¨ï¼šmaxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // å·¦é—­å³å¼€ï¼š[left, maxValueIndex)
        root->left = traversal(nums, left, maxValueIndex);

        // å·¦é—­å³å¼€ï¼š[maxValueIndex + 1, right)
        root->right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```



#### åˆå¹¶äºŒå‰æ ‘

ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ï¼š root1 å’Œ root2 ã€‚

æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ å°†å…¶ä¸­ä¸€æ£µè¦†ç›–åˆ°å¦ä¸€æ£µä¹‹ä¸Šæ—¶ï¼Œä¸¤æ£µæ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹å°†ä¼šé‡å ï¼ˆè€Œå¦ä¸€äº›ä¸ä¼šï¼‰ã€‚ä½ éœ€è¦å°†è¿™ä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ–°äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯ï¼šå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŠ ä½œä¸ºåˆå¹¶åèŠ‚ç‚¹çš„æ–°å€¼ï¼›å¦åˆ™ï¼Œä¸ä¸º null çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚

è¿”å›åˆå¹¶åçš„äºŒå‰æ ‘ã€‚

æ³¨æ„: åˆå¹¶è¿‡ç¨‹å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹
é“¾æ¥ï¼šhttps://leetcode.cn/problems/merge-two-binary-trees

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //ç»ˆæ­¢æ¡ä»¶
        if(root1 == NULL) return root2;
        if(root2 == NULL) return root1;
        //å•å±‚é€’å½’çš„é€»è¾‘
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left,root2->left);
        root1->right = mergeTrees(root1->right,root2->right);
        return root1;

    }
};
```

### äºŒå‰æ ‘-ååºç¯‡

ååºéå†äºŒå‰æ ‘æ˜¯ä¸€ç§è‡ªåº•å‘ä¸Šçš„éå†è¿‡ç¨‹ï¼›ååºéå†æ€æƒ³åœ¨å›æº¯ç®—æ³•ä¸­åº”ç”¨æœ€ä¸ºå¹¿æ³›ï¼Œæœ¬è´¨å°±æ˜¯ä¸€æ£µæ ‘å…ˆä»ä¸Šåˆ°ä¸‹ä¸æ“ä½œï¼Œä¸€æ’¸åˆ°åº•ï¼Œç„¶åä»å¶å­ç»“ç‚¹å¼€å§‹ï¼Œå‘ä¸Šæ ¹èŠ‚ç‚¹å›æº¯çš„è¿‡ç¨‹ï¼›è¯´ç™½äº†ä¹Ÿå°±æ˜¯é€’å½’çš„é€†è¿‡ç¨‹ã€‚

ä¸ºä»€ä¹ˆéƒ½æ˜¯ååºéå†å‘¢ï¼Ÿè¿™æ˜¯ä¸€ä¸ªå€¼å¾—æ€è€ƒçš„é—®é¢˜ã€‚

ç”¨å‰ªæçš„æ€æƒ³ï¼Œå»ç±»æ¯”é—®é¢˜ã€‚æ— è®ºæ˜¯å¯»æ‰¾æœ€å¤§ç›´å¾„ã€æœ€é•¿ç›¸åŒè·¯å¾„è¿˜æ˜¯æœ€å¤§è·¯å¾„å’Œï¼Œæœ¬è´¨ä¸Šéƒ½æ˜¯ä¸€ä¸ªä»æ ‘çš„åº•éƒ¨å‘æ ‘çš„é¡¶éƒ¨ï¼ˆrootï¼‰å»å‰ªæä¼˜åŒ–çš„è¿‡ç¨‹ã€‚å…¶å®å‰ªæè¯´çš„ä¸å‡†ç¡®ï¼Œä½†æ˜¯å‰ªæçš„ç›®çš„ä¹Ÿæ˜¯å¯»æ‰¾æœ€ä¼˜è·¯å¾„çš„é€‰å–è¿‡ç¨‹ã€‚å§‹ç»ˆè®°ä½ï¼Œååºæ˜¯å› ä¸ºè‡ªåº•å‘ä¸Šå¯»æ‰¾çš„æ€è·¯ï¼Œé‚£ä¹ˆè¿™äº›é—®é¢˜å°±å¯ä»¥æ€»ç»“å‡ºä¸€ä¸ªå¾ˆå¥½æ¨¡æ¿æ€è·¯ã€‚

#### äºŒå‰æ ‘çš„æœ€å¤§ç›´å¾„

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //ååºéå†å¦‚ä½•ç”¨ï¼Ÿ
 //éå†å‡½æ•°æ€ä¹ˆå†™ï¼Ÿ
 //è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ
 //ç»ˆæ­¢æ¡ä»¶æ˜¯ä»€ä¹ˆï¼Ÿ
 //å•å±‚éå†çš„é€»è¾‘æ˜¯ä»€ä¹ˆï¼Ÿ
class Solution {
private:
    //int ans = 1;
    //dfsæ·±åº¦ä¼˜å…ˆ
    //å‡½æ•°å®šä¹‰çš„ç±»å‹ä¸€å®šè¦å’Œè¿”å›å€¼å¯†åˆ‡ç›¸å…³ã€‚
    int travseral(TreeNode* node){
        //ç»ˆæ­¢æ¡ä»¶å°±æ˜¯å‘ä¸‹éå†åˆ°æ ¹èŠ‚ç‚¹
        if(node == NULL){
            return 0;
        }
        return max(travseral(node->left),travseral(node->right)) + 1;

    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        if(root == NULL) return 0;
        //å®šä¹‰å·¦å³å­æ ‘ä¹‹é—´çš„æœ€å¤§å€¼
        int cur = travseral(root->left) + travseral(root->right);
        //diameterOfBinaryTreeå‡½æ•°æ˜¯è¿”å›å·¦å³å­æ ‘è‡ªèº«çš„æœ€å¤§å€¼
        //æœ€åè¿”å›çš„æ˜¯å·¦å³å­æ ‘ã€å·¦å­æ ‘è‡ªèº«ã€å³å­æ ‘è‡ªèº«ä¸‰è€…ä¹‹é—´çš„æœ€å¤§å€¼
        return max({cur,diameterOfBinaryTree(root->left),diameterOfBinaryTree(root->right)});

    }
};
```

#### æœ€é•¿åŒå€¼è·¯å¾„

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ root ï¼Œè¿”å› æœ€é•¿çš„è·¯å¾„çš„é•¿åº¦ ï¼Œè¿™ä¸ªè·¯å¾„ä¸­çš„ æ¯ä¸ªèŠ‚ç‚¹å…·æœ‰ç›¸åŒå€¼ ã€‚ è¿™æ¡è·¯å¾„å¯ä»¥ç»è¿‡ä¹Ÿå¯ä»¥ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ã€‚

ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ ç”±å®ƒä»¬ä¹‹é—´çš„è¾¹æ•°è¡¨ç¤ºã€‚
é“¾æ¥ï¼šhttps://leetcode.cn/problems/longest-univalue-path

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int res = 0;
    //éå†å‡½æ•°æ—¶ä»€ä¹ˆã€è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ
    int dfs(TreeNode* root,int parentVal){
        //ç»ˆæ­¢æ¡ä»¶
        if(root == NULL){
            return 0;
        }
        // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œè®¡ç®—å·¦å³å­æ ‘å€¼ä¸º root.val çš„æœ€é•¿æ ‘æé•¿åº¦
        int left = dfs(root->left,root->val);
        int right = dfs(root->right,root->val);

        //ååºæ“ä½œ:ç›´æ¥è¿”å›å·¦å³å­æ ‘æœ€å¤§è·¯å¾„ä¹‹å’Œ
        res = max(res, left + right);
        // å¦‚æœ root æœ¬èº«å’Œä¸Šçº§å€¼ä¸åŒï¼Œé‚£ä¹ˆæ•´æ£µå­æ ‘éƒ½ä¸å¯èƒ½æœ‰åŒå€¼æ ‘æ
        if(root->val != parentVal){
            //æ³¨æ„è¿”å›å€¼çš„è®¾å®š
            return 0;
        }
        // å®ç°å‡½æ•°çš„å®šä¹‰ï¼š
        // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘ä» root å¼€å§‹å€¼ä¸º parentVal çš„æœ€é•¿æ ‘æé•¿åº¦
        // ç­‰äºå·¦å³å­æ ‘çš„æœ€é•¿æ ‘æé•¿åº¦çš„æœ€å¤§å€¼åŠ ä¸Š root èŠ‚ç‚¹æœ¬èº«
        return 1 + max(left,right);


    }
public:
    int longestUnivaluePath(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        dfs(root,root->val);
        return res;

    }
};
```

#### äºŒå‰æ ‘ä¸­æœ€å¤§è·¯å¾„å’Œ

**è·¯å¾„** è¢«å®šä¹‰ä¸ºä¸€æ¡ä»æ ‘ä¸­ä»»æ„èŠ‚ç‚¹å‡ºå‘ï¼Œæ²¿çˆ¶èŠ‚ç‚¹-å­èŠ‚ç‚¹è¿æ¥ï¼Œè¾¾åˆ°ä»»æ„èŠ‚ç‚¹çš„åºåˆ—ã€‚åŒä¸€ä¸ªèŠ‚ç‚¹åœ¨ä¸€æ¡è·¯å¾„åºåˆ—ä¸­ è‡³å¤šå‡ºç°ä¸€æ¬¡ ã€‚è¯¥è·¯å¾„ è‡³å°‘åŒ…å«ä¸€ä¸ª èŠ‚ç‚¹ï¼Œä¸”ä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹ã€‚

**è·¯å¾„å’Œ** æ˜¯è·¯å¾„ä¸­å„èŠ‚ç‚¹å€¼çš„æ€»å’Œã€‚

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶ æœ€å¤§è·¯å¾„å’Œ ã€‚
é“¾æ¥ï¼šhttps://leetcode.cn/problems/binary-tree-maximum-path-sum

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:

    int ret = INT_MIN;
    //å‡½æ•°å®šä¹‰å’Œè¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ
    // å®šä¹‰ï¼šè®¡ç®—ä»æ ¹èŠ‚ç‚¹ root ä¸ºèµ·ç‚¹çš„æœ€å¤§å•è¾¹è·¯å¾„å’Œ
    int dfs(TreeNode* root){
        //ç»ˆæ­¢æ¡ä»¶
        if(root == NULL){
            return 0;
        }
        int leftsum = max(0,dfs(root->left));
        int rightsum = max(0,dfs(root->right));
        // ååºéå†ä½ç½®ï¼Œé¡ºä¾¿æ›´æ–°æœ€å¤§è·¯å¾„å’Œ
        int pathsum = root->val + leftsum + rightsum;
        ret = max(ret,pathsum);
        // å®ç°å‡½æ•°å®šä¹‰ï¼Œå·¦å³å­æ ‘çš„æœ€å¤§å•è¾¹è·¯å¾„å’ŒåŠ ä¸Šæ ¹èŠ‚ç‚¹çš„å€¼
        // å°±æ˜¯ä»æ ¹èŠ‚ç‚¹ root ä¸ºèµ·ç‚¹çš„æœ€å¤§å•è¾¹è·¯å¾„å’Œ
        return max(leftsum,rightsum) + root->val;

    }
public:
    int maxPathSum(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        dfs(root);
        return ret;

    }
};
```



### äºŒå‰æœç´¢æ ‘

äºŒå‰æœç´¢æ ‘çš„åŸºæœ¬æ¦‚å¿µï¼š

äºŒå‰æœç´¢æ ‘æ˜¯ä¸€é¢—æœ‰åºæ ‘ï¼Œæ»¡è¶³å¦‚ä¸‹è§„åˆ™ï¼š

 * è‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å°äºå®ƒçš„æ ¹èŠ‚ç‚¹ä¸Šçš„å€¼ã€‚
 * è‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å¤§äºå®ƒçš„æ ¹èŠ‚ç‚¹ä¸Šçš„å€¼ã€‚
 * å®ƒçš„å·¦å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¹¦äºŒå‰æ’åºæ ‘ã€‚

äºŒå‰æœç´¢æ ‘çš„**ä¸­åºéå†**æ˜¯ä¸€ä¸ªä¸¥æ ¼çš„**é€’å¢åºåˆ—**ã€‚æ‰€æœ‰åœ¨é‡åˆ°äºŒå‰æœç´¢æ ‘çš„ç›¸å…³é—®é¢˜æ—¶ï¼Œå·§ç”¨**ä¸­åºéå†**æ˜¯è§£é¢˜çš„å…³é”®ä¹Ÿæ˜¯è§£å†³é—®é¢˜çš„å¿«é€Ÿæ–¹æ³•ã€‚

ä¸­åºéå†ä»£ç ï¼š

```c++
void searchBST(TreeNode* cur){
    if(cur == NULL) return;
    searchBST(root->left);//å·¦
    (ä¸­åºæ“ä½œ)
    searchBST(root->right);//å³
}
```

åœ¨è§£å†³äºŒå‰æœç´¢æ ‘çš„æœ€å€¼é—®é¢˜æ—¶ï¼Œé€’å½’å¯ä»¥é‡‡ç”¨ä¸¤ç§åŸºæœ¬çš„æ–¹å¼ï¼š

1.ä»¥**æ•°ç»„**ä¸ºåŸºæœ¬æ•°æ®ç»“æ„çš„æ–¹å¼

æ€è·¯ï¼š

ä»¥æ•°ç»„ä¸ºåŸºæœ¬çš„å­˜å‚¨æ–¹å¼ä¸­åºéå†å†™èµ·æ¥è¾ƒä¸ºç›´è§‚

```c++
vector<int> res;
void travser(TreeNode* root){
        if(root == NULL) return;
        travser(root->left);
        res.push_back(root->val);
        travser(root->right);
```

æ“ä½œæ˜¯æ”¾åœ¨**ä¸»å‡½æ•°**ä¸­è¿›è¡Œï¼Œåœ¨ä¸»å‡½æ•°åˆ©ç”¨forå¾ªç¯è¿›è¡Œæ±‚è§£æœ€å€¼å¾—é—®é¢˜ï¼›**ä¸­åºéå†**çš„æ–¹æ³•åªæ˜¯ä¸ºäº†å¾—åˆ°ä¸€ä¸ª**å‡åºçš„æ•°ç»„**ï¼Œå¾—ä»¥æŠŠä¸€é¢—äºŒå‰æ’åºæ ‘è½¬åŒ–æˆä¸€ä¸ªå•è°ƒé€’å¢çš„æ•°ç»„ï¼Œä»¥æ–¹ä¾¿å¤„ç†ã€‚

2.ä»¥**å•é“¾è¡¨**ä¸ºåŸºæœ¬æ•°æ®ç»“æ„çš„æ–¹å¼

æ€è·¯ï¼š

å•é“¾è¡¨çš„æ–¹å¼éœ€è¦è®¾ç½®ä¸¤ä¸ªèŠ‚ç‚¹æŒ‡é’ˆï¼š**curå’Œpre**ï¼Œç›¸å½“äºä¸€ä¸ªå¤´æŒ‡é’ˆå’Œä¸€ä¸ªå°¾æŒ‡é’ˆï¼›æ— è®ºæ˜¯åœ¨è¿­ä»£è¿˜æ˜¯åœ¨é€’å½’ä¸­ï¼Œå¤´å°¾æŒ‡é’ˆçš„è®¾å®šå°±æ˜¯å»æ‘†è„±åœ¨ä¸»å‡½æ•°ä¸­çš„äºŒæ¬¡forå¾ªç¯æ“ä½œï¼Œè€Œé™ä½æ—¶é—´å¤æ‚åº¦ï¼Œåœ¨é€’å½’çš„è¿‡ç¨‹ä¸­å³å®ç°æ“ä½œçš„ä¸€æ­¥åˆ°ä½ã€‚

```c++
TreeNode* pur = NULL;//è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
//TreeNode* cur = root;
if(root == NULL) return true;
//ä¸­åºéå†æ€è·¯
bool left = isValidBST(root->left);
//ç›¸å½“äºæ˜¯ä¸­åºéå†æ“ä½œä¸­åœ¨æ“ä½œçš„åˆ¤æ–­
//è¿ç”¨å¤´ç»“ç‚¹puråˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ—
if(pur != NULL && pur->val >= root->val) return false;
pur = root;
bool right = isValidBST(root->right);
//ç›¸å½“äºä¸­åºéå†å¤šåŠ äº†ä¸€ä¸ªifåˆ¤æ–­æ“ä½œ
```

#### åœ¨äºŒå‰æœç´¢æ ‘ä¸­å¯»æ‰¾èŠ‚ç‚¹

ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°å€¼ valã€‚

ä½ éœ€è¦åœ¨ BST ä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äº val çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› null ã€‚
é“¾æ¥ï¼šhttps://leetcode.cn/problems/search-in-a-binary-search-tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //ç¡®å®šé€’å½’å‡½æ•°å’Œå‚æ•°è®¾ç½®
    TreeNode* searchBST(TreeNode* root, int val) {
        //ç»ˆæ­¢æ¡ä»¶
        if(root == NULL || root->val == val) return root;
        //å› ä¸ºäºŒå‰æœç´¢æ ‘çš„èŠ‚ç‚¹å¤§å°æ˜¯æœ‰è§„å¾‹çš„æ‰€ä»¥å¯ä»¥ç®€åŒ–æœç´¢
        if(root->val > val) return searchBST(root->left,val);
        if(root->val < val) return searchBST(root->right,val);
        return NULL; 

    }
};
```

#### éªŒè¯äºŒå‰æœç´¢æ ‘

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚
é“¾æ¥ï¼šhttps://leetcode.cn/problems/validate-binary-search-tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    //æ€è·¯ï¼šä¸­åºéå†æ„å»ºä¸€ä¸ªé€’å¢çš„æ•°ç»„
    vector<int> res;
    void travser(TreeNode* root){
        if(root == NULL) return;
        travser(root->left);
        res.push_back(root->val);
        travser(root->right);
    }
public:
    bool isValidBST(TreeNode* root) {
        res.clear();
        travser(root);
        for(int i = 1;i < res.size();i++){
            if(res[i] <= res[i - 1]){
                return false;
            }
        }
        return true;
    }
};

æ”¹è¿›ï¼š
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pur = NULL;//è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
    //TreeNode* cur = root;
    bool isValidBST(TreeNode* root) {
        if(root == NULL) return true;
        //ä¸­åºéå†æ€è·¯
        bool left = isValidBST(root->left);
        //ç›¸å½“äºæ˜¯ä¸­åºéå†æ“ä½œä¸­åœ¨æ“ä½œçš„åˆ¤æ–­
        //è¿ç”¨å¤´ç»“ç‚¹puråˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ—
        if(pur != NULL && pur->val >= root->val) return false;
        pur = root;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

#### äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®

ç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› **æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼** ã€‚

å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
    traversal(root->right);
}

public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // ç»Ÿè®¡æœ‰åºæ•°ç»„çš„æœ€å°å·®å€¼
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;

    }
};

//è®¾ç½®åŒèŠ‚ç‚¹çš„å¦ä¸€ç§åšæ³•
class Solution {
private:
int result = INT_MAX;
TreeNode* pre;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur->left);   // å·¦
    if (pre != NULL){       // ä¸­
        result = min(result, cur->val - pre->val);
    }
    pre = cur; // è®°å½•å‰ä¸€ä¸ª
    traversal(cur->right);  // å³
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```

#### äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°

ç»™ä½ ä¸€ä¸ªå«é‡å¤å€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ‰¾å‡ºå¹¶è¿”å› BST ä¸­çš„æ‰€æœ‰ ä¼—æ•°ï¼ˆå³ï¼Œå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚

å¦‚æœæ ‘ä¸­æœ‰ä¸æ­¢ä¸€ä¸ªä¼—æ•°ï¼Œå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚
é“¾æ¥ï¼šhttps://leetcode.cn/problems/find-mode-in-binary-search-tree

```c++
class Solution {
private:
    int maxCount; // æœ€å¤§é¢‘ç‡
    int count; // ç»Ÿè®¡é¢‘ç‡
    TreeNode* pre;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // å·¦
                                    // ä¸­
        if (pre == NULL) { // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            count = 1;
        } else if (pre->val == cur->val) { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸åŒ
            count++;
        } else { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ä¸åŒ
            count = 1;
        }
        pre = cur; // æ›´æ–°ä¸Šä¸€ä¸ªèŠ‚ç‚¹

        if (count == maxCount) { // å¦‚æœå’Œæœ€å¤§å€¼ç›¸åŒï¼Œæ”¾è¿›resultä¸­
            result.push_back(cur->val);
        }

        if (count > maxCount) { // å¦‚æœè®¡æ•°å¤§äºæœ€å¤§å€¼é¢‘ç‡
            maxCount = count;   // æ›´æ–°æœ€å¤§é¢‘ç‡
            result.clear();     // å¾ˆå…³é”®çš„ä¸€æ­¥ï¼Œä¸è¦å¿˜è®°æ¸…ç©ºresultï¼Œä¹‹å‰resulté‡Œçš„å…ƒç´ éƒ½å¤±æ•ˆäº†
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // å³
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        result.clear();

        searchBST(root);
        return result;
    }
};

//è¿­ä»£æ³•
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int maxCount = 0; // æœ€å¤§é¢‘ç‡
        int count = 0; // ç»Ÿè®¡é¢‘ç‡
        vector<int> result;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
                st.push(cur); // å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ
                cur = cur->left;                // å·¦
            } else {
                cur = st.top();
                st.pop();                       // ä¸­
                if (pre == NULL) { // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
                    count = 1;
                } else if (pre->val == cur->val) { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸åŒ
                    count++;
                } else { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ä¸åŒ
                    count = 1;
                }
                if (count == maxCount) { // å¦‚æœå’Œæœ€å¤§å€¼ç›¸åŒï¼Œæ”¾è¿›resultä¸­
                    result.push_back(cur->val);
                }

                if (count > maxCount) { // å¦‚æœè®¡æ•°å¤§äºæœ€å¤§å€¼é¢‘ç‡
                    maxCount = count;   // æ›´æ–°æœ€å¤§é¢‘ç‡
                    result.clear();     // å¾ˆå…³é”®çš„ä¸€æ­¥ï¼Œä¸è¦å¿˜è®°æ¸…ç©ºresultï¼Œä¹‹å‰resulté‡Œçš„å…ƒç´ éƒ½å¤±æ•ˆäº†
                    result.push_back(cur->val);
                }
                pre = cur;
                cur = cur->right;               // å³
            }
        }
        return result;
    }
};
```

#### äºŒå‰æ ‘/æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
é“¾æ¥ï¼šhttps://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree

```c++
//æ™®é€šäºŒå‰æ ‘çš„æœ€è¿‘ç¥–å…ˆ
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == NULL){
            return root; 
        }
        //å¯»æ‰¾å…¬å…±ç¥–å…ˆçš„æ€è·¯æ˜¯è¦é€šè¿‡è‡ªåº•å‘ä¸Šçš„ååºéå†åˆ¤æ–­å…¬å…±ç¥–å…ˆ
        TreeNode *left = lowestCommonAncestor(root->left,p,q);
        TreeNode *right = lowestCommonAncestor(root->right,p,q);
        //ååºæ“ä½œ
        if(left != NULL && right != NULL) return root;

        if(left == NULL && right != NULL) return right;
        else if(left != NULL && right == NULL) return left;
        else{
            return NULL;
        }

        
    }
};

//äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘ç¥–å…ˆ
//æ³¨æ„ç»“åˆæœç´¢åŒºé—´è¿›è¡Œåˆ¤æ–­
class Solution {
private:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if (cur == NULL) return cur;
                                                        // ä¸­
        if (cur->val > p->val && cur->val > q->val) {   // å·¦
            TreeNode* left = traversal(cur->left, p, q);
            if (left != NULL) {
                return left;
            }
        }

        if (cur->val < p->val && cur->val < q->val) {   // å³
            TreeNode* right = traversal(cur->right, p, q);
            if (right != NULL) {
                return right;
            }
        }
        return cur;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
```



## BFSå¹¿åº¦ä¼˜å…ˆæœç´¢

äºŒå‰æ ‘çš„å¹¿åº¦ä¼˜å…ˆæœç´¢->äºŒå‰æ ‘çš„å±‚åºéå†ï¼›è€Œè®²åˆ°å±‚åºéå†ï¼Œåˆå¯ä»¥æŠŠè§£é¢˜æ€è·¯åˆ†æˆä¸¤ç§ï¼šé€’å½’æ³•ã€è¿­ä»£æ³•ã€‚

è¿™æ˜¯ä¸»è¦å†™è¿­ä»£æ³•ï¼Œå› ä¸ºç›¸æ¯”äºé€’å½’æ³•çš„å±‚åºéå†ï¼Œè¿­ä»£æ³•çš„BFSç®—æ³•æ˜¯æœ€èƒ½ä½“ç°å‡ºBFSæ€è·¯çš„æ–¹æ³•ã€‚

éœ€è¦ç”¨åˆ°çš„æ•°æ®ç»“æ„ï¼šé˜Ÿåˆ—->å‡†ç¡®çš„è¯´æ˜¯æŒ‡é’ˆé˜Ÿåˆ—.

ä¸‹é¢å’±ä»¬å°±æ‰‹æ’¸ä¸€ä¸ªBFSç®—æ³•ï¼š

```c++
#include<iostream>
#include<queue>
#include<stdlib.h>
#include<vector>

using namespace std;

struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int BFS(TreeNode * root){
    if(root == NULL) return 0;  //ç»ˆæ­¢æ¡ä»¶åˆ¤æ–­
    queue<TreeNode*> que;   //åˆ›å»ºé˜Ÿåˆ—
    que.push(root); //å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
    int sum = 0;//è®¾ç½®è®°å½•ä¿¡å·
    while(!que.empty()){
        sum = 0;//æ¯æ¬¡å¾ªç¯ä¹‹å‰å½’é›¶ï¼Œè®°å½•å•å±‚çš„å’Œ
        int sz = que.size();//æ±‚å‡ºé˜Ÿåˆ—é•¿åº¦
        for(int i = 0;i < sz;i++){
            //forå¾ªç¯ä¾æ¬¡å¯¹æ¯å±‚æ±‚å’Œ
            TreeNode* cur = que.front();//å–å¯¹å¤´å…ƒç´ ä¸ºåˆå§‹æŒ‡é’ˆèŠ‚ç‚¹
            que.pop();
            sum += cur->val;
            if(cur->left != NULL){
                que.push(cur->left);
            }
            if(cur->right != NULL){
                que.push(cur->right);
            }

        }
    }
    return sum;
}
```

å¹¿åº¦ä¼˜å…ˆæœç´¢â€”â€”æœ¬è´¨ä¸Šæ˜¯äºŒå‰æ ‘çš„å±‚åºéå†ï¼ˆåŠ›æ‰£102é¢˜ï¼‰

è¿ç”¨çš„æ•°æ®ç»“æ„æ˜¯é˜Ÿåˆ—å’Œæ•°ç»„ï¼›è¿ç”¨æ•°ç»„ä¿å­˜æœ€åçš„ç»“æœï¼Œè¿ç”¨é˜Ÿåˆ—å»æ¨¡æ‹Ÿå±‚åºéå†çš„è¿‡ç¨‹ã€‚

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // è¿™é‡Œä¸€å®šè¦ä½¿ç”¨å›ºå®šå¤§å°sizeï¼Œä¸è¦ä½¿ç”¨que.size()ï¼Œå› ä¸ºque.sizeæ˜¯ä¸æ–­å˜åŒ–çš„
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## DFSæ·±åº¦ä¼˜å…ˆæœç´¢

æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé¡¾åæ€ä¹‰å°±æ˜¯ä¸€æ¡é“è·¯èµ°åˆ°åº•ï¼›ç±»æ¯”ä¸€æ£µæ ‘çš„è¯ï¼Œå°±æ˜¯ä»**ä¸Šåˆ°ä¸‹å…ˆåºéå†**ä¸€æ£µæ ‘ã€‚æ·±åº¦ä¼˜å…ˆï¼Œå¾—åˆ°çš„ä¸€å®šå…ˆæ˜¯æ ‘çš„æ·±åº¦ï¼ˆé«˜åº¦ï¼‰ã€‚å› ä¸ºå…¶é€šå¸¸å’Œå›æº¯ç®—æ³•ç›¸ç»“åˆä½¿ç”¨ï¼Œæ‰€ä»¥å…¶é‡è¦æ€§ä¸å¯ä¼°é‡ã€‚å­¦ä¼šDFSå°±æ˜¯å­¦ä¼šä½¿ç”¨å…¶**æš´åŠ›æœç´¢**çš„åŠŸèƒ½ï¼Œå­¦ä¼š**èªæ˜çš„ç©·ä¸¾**ã€‚é¿å…é«˜å¼ºåº¦çš„å¤šå¾ªç¯åµŒå¥—forå¾ªç¯ï¼Œæ—¢æµªè´¹æ—¶é—´åˆæµªè´¹ç©ºé—´ï¼›é‚£ä¸ºä»€ä¹ˆæš´åŠ›æœç´¢ä¹Ÿéœ€è¦èŠ±è´¹å¤§é‡æ—¶é—´ä½†æ˜¯è¿˜æœ‰å®ƒå­˜åœ¨çš„é“ç†å‘¢ï¼Ÿæˆ‘è®¤ä¸ºï¼Œå­˜åœ¨å³åˆç†ï¼Œå¾ˆå¤šæ—¶å€™DFSç®—æ³•å­˜åœ¨ç¡®å®æ˜¯æœ‰ä»–çš„ä¼˜åŠ¿çš„ã€‚æœ€èµ·ç ï¼ŒDFSå°±æ˜¯åˆ©ç”¨é€’å½’æ€ç»´å»ä¹¦å†™ç¨‹åºçš„ä¸€ä¸ªå¥½æ¨¡æ¿ã€‚è™½ç„¶æœ¬è´¨ä¸Šå’Œforå¾ªç¯å·®åˆ«ä¸å¤§ï¼Œä½†æ˜¯ï¼Œä¸€æ—¦é—®é¢˜è§„æ¨¡å˜å¤§ï¼Œforå¾ªç¯æ‰¿æ‹…ä¸äº†å¤§å·¥ç¨‹æ—¶ï¼Œå¤šå±‚å¾ªç¯å¾ˆå®¹æ˜“æŠŠäººç»•æ‡µè€Œä¸”æ—¶é—´å¤æ‚åº¦æ˜¯å‘ˆç°næ–¹é‡çº§å¢åŠ ã€‚è¿™æ—¶ï¼ŒDFSçš„é€’å½’éå†å°±èŠ‚çœäº†å¾ˆå¤§çš„ç©ºé—´å¤æ‚åº¦ï¼ˆæ—¶é—´å¤æ‚åº¦è™½ç„¶ä¸æ•¢ä¿è¯ï¼‰ï¼Œé¿å…äº†é«˜å¼ºåº¦çš„å¾ªç¯åµŒå¥—ï¼Œä½¿å¾—ç¨‹åºå¾—ä»¥è¿è¡Œå‡ºç»“æœã€‚åŒæ ·ï¼Œç©·ä¸¾ä¸æš´åŠ›æ˜¯ç¨‹åºè®¾è®¡æœ€æœ¬æºçš„æ€è·¯ï¼Œè®¡ç®—æœºè§£å†³é—®é¢˜æœ€å¼€å§‹çš„æ–¹æ³•å°±æ˜¯ç©·ä¸¾ï¼Œäººä»¬åªæ˜¯æŒæ¡äº†æ–¹æ³•ï¼Œè®©è®¡ç®—æœºå­¦ä¼šå»èªæ˜çš„ç©·ä¸¾ã€‚ç»¼ä¸Šï¼Œè¿™æ˜¯æˆ‘ç†è§£çš„DFSå­˜åœ¨çš„ç°å®æ„ä¹‰ä¸å…¶é‡è¦æ€§ã€‚

### DPSç®—æ³•çš„è®¾è®¡åˆ†æ

åœ¨å­¦ä¹ ä¹¦å†™DFSå‰ä¸€å®šè¦å­¦ä¼šä¹¦å†™æ ‘çš„éå†ï¼ˆé€’å½’éå†ï¼‰

```python
res.append(root.val)
preorder(root.left)
preorder(root.right)
```

ç†è§£äº†æ ‘çš„é€’å½’éå†ä¹‹åï¼Œæ‰èƒ½ä¹¦å†™å‡ºDFS**é€’å½’çš„é€»è¾‘**ã€‚æœ€æœ¬è´¨çš„è¿˜æ˜¯è¦ç†è§£é€’å½’çš„é€»è¾‘~

DFSä¹¦å†™å¥—è·¯ï¼š

1.å®šä¹‰å­˜æ”¾ç»“æœå˜é‡

```c++
vector<vector<int>> res;//å­˜æ”¾æœ€ç»ˆç»“æœ
vector<int> path;//å­˜æ”¾è·¯å¾„
```

2.å›æº¯å‡½æ•°çš„æ¡†æ¶ä¹¦å†™ä¸å‚æ•°çš„ç¡®å®š

```c++
void backtrack(å‚æ•°......)
```

3.é€’å½’è¿‡ç¨‹ä¸­æœç´¢çš„é€»è¾‘

### DFSç®—æ³•ä¸å›æº¯ç®—æ³•çš„å…³ç³»

### DFSç®—æ³•ä¹¦å†™çš„æ¨¡æ¿å¥—è·¯

DFSçš„ç®—æ³•å¥—è·¯ä¹¦å†™å…³é”®åœ¨äºæ­£ç¡®ç†è§£é€’å½’å‡½æ•°çš„å‚æ•°è°ƒç”¨ä¸ç»ˆæ­¢æ¡ä»¶çš„ç¡®ç«‹ã€‚

## å›æº¯ç®—æ³•

å›æº¯é“ºå«:äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

```c++
**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void traversal(TreeNode* cur,vector<int> &path,vector<string> &res){

        path.push_back(cur->val);
        //åˆ°è¾¾å¶å­ç»“ç‚¹
        if(cur->left == NULL && cur->right == NULL){
            string spath;
            for(int i = 0;i < path.size() - 1;i++){
                spath += to_string(path[i]);
                spath += "->";
            }
            spath += to_string(path[path.size() - 1]);
            res.push_back(spath);
            return;
        }
        if(cur->left){
            traversal(cur->left,path,res);
            path.pop_back();//å›æº¯
        }
        if(cur->right){
            traversal(cur->right,path,res);
            path.pop_back();//å›æº¯
        }
    }
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        vector<int> path;
        if(root == NULL) return res;
        traversal(root,path,res);
        return res;
    }
};
```

å›æº¯ç®—æ³•å’Œæˆ‘ä»¬å¸¸è¯´çš„ DFS ç®—æ³•éå¸¸ç±»ä¼¼ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ç§æš´åŠ›ç©·ä¸¾ç®—æ³•ã€‚å›æº¯ç®—æ³•å’Œ DFS ç®—æ³•çš„ç»†å¾®å·®åˆ«æ˜¯ï¼š**å›æº¯ç®—æ³•æ˜¯åœ¨éå†ã€Œæ ‘æã€ï¼ŒDFS ç®—æ³•æ˜¯åœ¨éå†ã€ŒèŠ‚ç‚¹ã€**ã€‚

å›æº¯ç®—æ³•è§£å†³ä»ä¸Šåˆ°ä¸‹ä¸€æ¬¡éå†æ•´é¢—æ ‘ï¼Œåœ¨å…¶æ¨¡æ¿ä¸­ï¼Œè¿ç”¨forå¾ªç¯å»æ¨ªå‘éå†â€”â€”åšé€‰æ‹©ï¼›åˆ©ç”¨é€’å½’ï¼ˆå›æº¯å‡½æ•°ï¼‰å»çºµå‘éå†â€”â€”è·¯å¾„ã€‚

è·¯å¾„ã€é€‰æ‹©ã€ç»ˆæ­¢æ¡ä»¶

```python
#ä¸œå“¥æ¨¡æ¿
result = []
def backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨):
    if æ»¡è¶³ç»“æŸæ¡ä»¶:
        result.add(è·¯å¾„)
        return
    
    for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
        åšé€‰æ‹©
        backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨)
        æ’¤é”€é€‰æ‹©
```

```c++
//å¡å“¥æ¨¡æ¿
void backtrack(å‚æ•°){
    if(ç»ˆæ­¢æ¡ä»¶){
        å­˜æ”¾ç»“æœ;
        return;
    }
    
    for(é€‰æ‹©:æœ¬å±‚é›†åˆä¸­çš„å…ƒç´ ){
        å¤„ç†èŠ‚ç‚¹;
        backtrack(è·¯å¾„ï¼Œé€‰æ‹©);
        å›æº¯,æ’¤é”€ç»“æœ;
    }
}
```

å›æº¯ç®—æ³•å°±æ˜¯ä¸ªå¤šå‰æ ‘çš„éå†é—®é¢˜ï¼Œå…³é”®å°±æ˜¯åœ¨å‰åºéå†å’Œååºéå†çš„ä½ç½®åšä¸€äº›æ“ä½œ:

```python
def backtrack(...):
    for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
        åšé€‰æ‹©
        backtrack(...)
        æ’¤é”€é€‰æ‹©
```

**å†™ `backtrack` å‡½æ•°æ—¶ï¼Œéœ€è¦ç»´æŠ¤èµ°è¿‡çš„ã€Œè·¯å¾„ã€å’Œå½“å‰å¯ä»¥åšçš„ã€Œé€‰æ‹©åˆ—è¡¨ã€ï¼Œå½“è§¦å‘ã€Œç»“æŸæ¡ä»¶ã€æ—¶ï¼Œå°†ã€Œè·¯å¾„ã€è®°å…¥ç»“æœé›†**ã€‚

å›æº¯æ³•ä¸­çš„å‚æ•°ä¸æ˜¯ä¸€æ¬¡æ€§å°±å¯ä»¥å®Œå…¨ç¡®å®šä¸‹æ¥ï¼Œä¸€èˆ¬å…ˆå†™é€»è¾‘ï¼Œéœ€è¦ä»€ä¹ˆå‚æ•°å°±å¯ä»¥å¡«å†™ä»€ä¹ˆå‚æ•°ã€‚

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

æ— è®ºæ˜¯æ’åˆ—ã€ç»„åˆè¿˜æ˜¯å­é›†é—®é¢˜ï¼Œç®€å•è¯´æ— éå°±æ˜¯è®©ä½ ä»åºåˆ— `nums` ä¸­ä»¥ç»™å®šè§„åˆ™å–è‹¥å¹²å…ƒç´ ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç§å˜ä½“ï¼š

**å½¢å¼ä¸€ã€å…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼Œå³ `nums` ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™ä¹Ÿæ˜¯æœ€åŸºæœ¬çš„å½¢å¼**ã€‚

ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ `nums = [2,3,6,7]`ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥åªæœ‰ `[7]`ã€‚

```c++
/* ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */
void backtrack(int[] nums, int start) {
    // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
    for (int i = start; i < nums.length; i++) {
        // åšé€‰æ‹©
        track.addLast(nums[i]);
        // æ³¨æ„å‚æ•°
        backtrack(nums, i + 1);
        // æ’¤é”€é€‰æ‹©
        track.removeLast();
    }
}

/* æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // å‰ªæé€»è¾‘
        if (used[i]) {
            continue;
        }
        // åšé€‰æ‹©
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // æ’¤é”€é€‰æ‹©
        track.removeLast();
        used[i] = false;
    }
}
```

**å½¢å¼äºŒã€å…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼Œå³ `nums` ä¸­çš„å…ƒç´ å¯ä»¥å­˜åœ¨é‡å¤ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡**ã€‚

ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ `nums = [2,5,2,1,2]`ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ `[2,2,2,1]` å’Œ `[5,2]`ã€‚

```c++
Arrays.sort(nums);
/* ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */
void backtrack(int[] nums, int start) {
    // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
    for (int i = start; i < nums.length; i++) {
        // å‰ªæé€»è¾‘ï¼Œè·³è¿‡å€¼ç›¸åŒçš„ç›¸é‚»æ ‘æ
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // åšé€‰æ‹©
        track.addLast(nums[i]);
        // æ³¨æ„å‚æ•°
        backtrack(nums, i + 1);
        // æ’¤é”€é€‰æ‹©
        track.removeLast();
    }
}


Arrays.sort(nums);
/* æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // å‰ªæé€»è¾‘
        if (used[i]) {
            continue;
        }
        // å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        // åšé€‰æ‹©
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // æ’¤é”€é€‰æ‹©
        track.removeLast();
        used[i] = false;
    }
}
```

**å½¢å¼ä¸‰ã€å…ƒç´ æ— é‡å¯å¤é€‰ï¼Œå³ `nums` ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥è¢«ä½¿ç”¨è‹¥å¹²æ¬¡**ã€‚

ä¸Šé¢ç”¨ç»„åˆé—®é¢˜ä¸¾çš„ä¾‹å­ï¼Œä½†æ’åˆ—ã€ç»„åˆã€å­é›†é—®é¢˜éƒ½å¯ä»¥æœ‰è¿™ä¸‰ç§åŸºæœ¬å½¢å¼ï¼Œæ‰€ä»¥å…±æœ‰ 9 ç§å˜åŒ–ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œé¢˜ç›®ä¹Ÿå¯ä»¥å†æ·»åŠ å„ç§é™åˆ¶æ¡ä»¶ï¼Œæ¯”å¦‚è®©ä½ æ±‚å’Œä¸º `target` ä¸”å…ƒç´ ä¸ªæ•°ä¸º `k` çš„ç»„åˆï¼Œé‚£è¿™ä¹ˆä¸€æ¥åˆå¯ä»¥è¡ç”Ÿå‡ºä¸€å †å˜ä½“ï¼Œæ€ªä¸å¾—é¢è¯•ç¬”è¯•ä¸­ç»å¸¸è€ƒåˆ°æ’åˆ—ç»„åˆè¿™ç§åŸºæœ¬é¢˜å‹ã€‚

```c++
/* ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */
void backtrack(int[] nums, int start) {
    // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
    for (int i = start; i < nums.length; i++) {
        // åšé€‰æ‹©
        track.addLast(nums[i]);
        // æ³¨æ„å‚æ•°
        backtrack(nums, i);
        // æ’¤é”€é€‰æ‹©
        track.removeLast();
    }
}


/* æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // åšé€‰æ‹©
        track.addLast(nums[i]);
        backtrack(nums);
        // æ’¤é”€é€‰æ‹©
        track.removeLast();
    }
}
```

**ä½†æ— è®ºå½¢å¼æ€ä¹ˆå˜åŒ–ï¼Œå…¶æœ¬è´¨å°±æ˜¯ç©·ä¸¾æ‰€æœ‰è§£ï¼Œè€Œè¿™äº›è§£å‘ˆç°æ ‘å½¢ç»“æ„ï¼Œæ‰€ä»¥åˆç†ä½¿ç”¨å›æº¯ç®—æ³•æ¡†æ¶ï¼Œç¨æ”¹ä»£ç æ¡†æ¶å³å¯æŠŠè¿™äº›é—®é¢˜ä¸€ç½‘æ‰“å°½**ã€‚

### æ’åˆ—é—®é¢˜

ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ `nums` ï¼Œè¿”å›å…¶ *æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—* ã€‚ä½ å¯ä»¥ **æŒ‰ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& nums,vector<bool>& used){
        //æ­¤æ—¶æ‰¾åˆ°è¯´æ˜æ‰¾åˆ°äº†ä¸€ç»„
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0;i < nums.size();i++){
            if(used[i] == true) continue;//è¯´æ˜pathä¸­å·²ç»æ”¶é›†åˆ°äº†è¯¥å…ƒç´ 
            used[i] = true;
            path.push_back(nums[i]);
            backtrack(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        res.clear();
        path.clear();
        vector<bool> used(nums.size(),false);
        backtrack(nums,used);
        return res;

    }
};

```

216.ç»„åˆæ€»æ•°||

æ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ä¹‹å’Œä¸º n çš„ k ä¸ªæ•°çš„ç»„åˆï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š

åªä½¿ç”¨æ•°å­—1åˆ°9ï¼Œæ¯ä¸ªæ•°å­— æœ€å¤šä½¿ç”¨ä¸€æ¬¡ 
è¿”å› æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆç»„åˆçš„åˆ—è¡¨ ã€‚è¯¥åˆ—è¡¨ä¸èƒ½åŒ…å«ç›¸åŒçš„ç»„åˆä¸¤æ¬¡ï¼Œç»„åˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚

```c++
class Solution {
private:
    //è®¾ç½®äºŒç»´ç»“æœæ•°ç»„ä¸è·¯åŠ²æ•°ç»„
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(int tarSum,int k,int sum,int startIndex){
        //æ­¤æ—¶æ‰¾åˆ°äº†ä¸€ç»„
        if(path.size() == k){
            if(sum == tarSum) res.push_back(path);
            return;
        }
        //å•å±‚é€’å½’çš„é€»è¾‘
        for(int i = startIndex;i <= 9;i++){
            sum += i;
            path.push_back(i);
            //æ³¨æ„å‚æ•°çš„å–å€¼æ˜¯i+1ï¼Œè°ƒæ•´ä¸‹ä¸€å±‚é€’å½’çš„startIndex
            backtrack(tarSum,k,sum,i + 1);
            sum -= i;//å›æº¯
            path.pop_back();//å›æº¯
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        res.clear();
        path.clear();
        backtrack(n,k,0,1);
        return res;

    }
};
```

### ç»„åˆæ€»å’Œ

39ï¼š

ç»™ä½ ä¸€ä¸ª **æ— é‡å¤å…ƒç´ ** çš„æ•´æ•°æ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° target ï¼Œæ‰¾å‡º candidates ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° target çš„ æ‰€æœ‰ ä¸åŒç»„åˆ ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è¿™äº›ç»„åˆã€‚

candidates ä¸­çš„ åŒä¸€ä¸ª æ•°å­—å¯ä»¥ æ— é™åˆ¶é‡å¤è¢«é€‰å– ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚ 

å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º target çš„ä¸åŒç»„åˆæ•°å°‘äº 150ä¸ªã€‚

```c++
class Solution {
private:
    //å®šä¹‰å…¨å±€å˜é‡å­˜æ”¾ç»“æœ
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& candidates,int target,int sum,int startIndex){
        if(sum > target){
            return;
        }
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex;i <candidates.size();i++){
            sum += candidates[i];
            path.push_back(candidates[i]);
            //ä¸éœ€è¦i+1ï¼Œè¡¨ç¤ºå¯ä»¥ä»è‡ªèº«å¼€å§‹å–
            backtrack(candidates,target,sum,i);
            sum -= candidates[i];
            path.pop_back();
            
        }
    }

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        path.clear();
        res.clear();
        backtrack(candidates,target,0,0);
        return res;

    }
};
```

40ï¼š

ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚

candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ ä¸€æ¬¡ ã€‚

æ³¨æ„ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚

æ³¨æ„æœ¬é¢˜ä¸å‰ä¸€é¢˜çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œæœ¬é¢˜ä¸­çš„candidatesä¸­å­˜åœ¨é‡å¤çš„å…ƒç´ ï¼Œåœ¨å›æº¯è¿‡ç¨‹ä¸­ï¼ŒåŒä¸€å±‚çš„éå†è¦æ³¨æ„é¿å…é‡å¤å…ƒç´ çš„ä½¿ç”¨ã€‚

å¢åŠ äº†usedæ•°ç»„æ¥åˆ¤æ–­é‡å¤å…ƒç´ çš„ä½¿ç”¨æ¬¡æ•°ï¼Œä»è€Œé¿å…é‡å¤å…ƒç´ çš„ä½¿ç”¨æƒ…å†µã€‚

```c++
class Solution {
private:
    //å®šä¹‰å…¨å±€å˜é‡
    //æœ¬é¢˜çš„åŒºåˆ«åœ¨äºï¼Œcandidatesä¸­å­˜åœ¨é‡å¤å…ƒç´ ï¼Œè¦æƒ³åŠæ³•è¿›è¡Œå»é‡
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& candidates, int target,int sum,int startIndex,vector<bool>& used){
        if(sum > target){
            return;
        }
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex;i < candidates.size() && sum + candidates[i] <= target;i++){
            if(i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false){
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtrack(candidates,target,sum,i + 1,used);
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(),false);
        path.clear();
        res.clear();
        sort(candidates.begin(),candidates.end());
        backtrack(candidates,target,0,0,used);
        return res;

    }
};
```

### å­é›†é—®é¢˜

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  **äº’ä¸ç›¸åŒ** ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è§£é›†ã€‚

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& nums,int startIndex){
        res.push_back(path);//æ”¶é›†å­é›†è¦æ”¾åœ¨ç»ˆæ­¢æ¡ä»¶ä¸Šé¢å¦åˆ™ä¼šæ¼æ‰
        if(startIndex >= nums.size()){
            return;
        }
        for(int i = startIndex;i < nums.size();i++){
            path.push_back(nums[i]);
            backtrack(nums,i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsets(vector<int>& nums) {
        path.clear();
        res.clear();
        backtrack(nums,0);
        return res;

    }
};
```

numä¸­å­˜åœ¨å¯é‡å¤å…ƒç´ æ—¶çš„æƒ…å†µæ—¶åŒæ ·é‡‡ç”¨usedæ•°ç»„è¿›è¡Œé‡å¤é¿å…ã€‚

**æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬é€šè¿‡ä¿è¯å…ƒç´ ä¹‹é—´çš„ç›¸å¯¹é¡ºåºä¸å˜æ¥é˜²æ­¢å‡ºç°é‡å¤çš„å­é›†**ã€‚

å«æœ‰é‡å¤å…ƒç´ æ—¶ä¸€å®šè¦æ³¨æ„åœ¨æœ€åä¸»å‡½æ•°ä¸­**å…ˆå¯¹é¢˜ç»™é›†åˆå…ˆè¿›è¡Œæ’åº**ã€‚

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& nums,int startIndex,vector<bool>& used){
        res.push_back(path);
        if(startIndex >= nums.size()){
            return;
        }
        for(int i = startIndex;i < nums.size();i++){
            if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false){
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums,i + 1,used);
            used[i] = false;
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
        res.clear();
        path.clear();
        //å»é‡è¦æ’åº
        sort(nums.begin(),nums.end());
        backtrack(nums, 0, used);
        return res;
    }
};
```

### [Nçš‡å](https://leetcode.cn/problems/n-queens)

æŒ‰ç…§å›½é™…è±¡æ£‹çš„è§„åˆ™ï¼Œçš‡åå¯ä»¥æ”»å‡»ä¸ä¹‹å¤„åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—æˆ–åŒä¸€æ–œçº¿ä¸Šçš„æ£‹å­ã€‚

n çš‡åé—®é¢˜ ç ”ç©¶çš„æ˜¯å¦‚ä½•å°† n ä¸ªçš‡åæ”¾ç½®åœ¨ nÃ—n çš„æ£‹ç›˜ä¸Šï¼Œå¹¶ä¸”ä½¿çš‡åå½¼æ­¤ä¹‹é—´ä¸èƒ½ç›¸äº’æ”»å‡»ã€‚

ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›æ‰€æœ‰ä¸åŒçš„ n çš‡åé—®é¢˜ çš„è§£å†³æ–¹æ¡ˆã€‚

æ¯ä¸€ç§è§£æ³•åŒ…å«ä¸€ä¸ªä¸åŒçš„ n çš‡åé—®é¢˜ çš„æ£‹å­æ”¾ç½®æ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆä¸­ 'Q' å’Œ '.' åˆ†åˆ«ä»£è¡¨äº†çš‡åå’Œç©ºä½ã€‚

## è´ªå¿ƒç®—æ³•

## åŠ¨æ€è§„åˆ’-Dynamic Programming

### åŠ¨æ€è§„åˆ’åŸºç¡€

->åˆ©ç”¨å­é—®é¢˜çš„æœ€ä¼˜è§£å»æ±‚è§£å…¨å±€æœ€ä¼˜è§£;å–„äºåˆ©ç”¨äºŒä½è¡¨å¯»æ‰¾æ€è·¯ã€‚

**åŠ¨æ€è§„åˆ’é—®é¢˜çš„ä¸€èˆ¬å½¢å¼å°±æ˜¯æ±‚æœ€å€¼**ï¼ŒåŠ¨æ€è§„åˆ’å…¶å®æ˜¯è¿ç­¹å­¦çš„ä¸€ç§æœ€ä¼˜åŒ–æ–¹æ³•ï¼Œåªä¸è¿‡åœ¨è®¡ç®—æœºé—®é¢˜ä¸Šåº”ç”¨æ¯”è¾ƒå¤šã€‚æ—¢ç„¶æ˜¯è¦æ±‚æœ€å€¼ï¼Œæ ¸å¿ƒé—®é¢˜æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ**æ±‚è§£åŠ¨æ€è§„åˆ’çš„æ ¸å¿ƒé—®é¢˜æ˜¯ç©·ä¸¾**ã€‚å› ä¸ºè¦æ±‚æœ€å€¼ï¼Œè‚¯å®šè¦æŠŠæ‰€æœ‰å¯è¡Œçš„ç­”æ¡ˆç©·ä¸¾å‡ºæ¥ï¼Œç„¶ååœ¨å…¶ä¸­æ‰¾æœ€å€¼å‘—ã€‚ä½†æ˜¯ï¼Œç©·ä¸¾æ‰€æœ‰å¯è¡Œè§£å…¶å®å¹¶ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹ï¼Œéœ€è¦ä½ ç†Ÿç»ƒæŒæ¡é€’å½’æ€ç»´ï¼Œåªæœ‰åˆ—å‡º**æ­£ç¡®çš„ã€ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€**ï¼Œæ‰èƒ½æ­£ç¡®åœ°ç©·ä¸¾ã€‚å› æ­¤ï¼Œå†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„ä¸€èˆ¬æ€è·¯æ˜¯ï¼š

**æ˜ç¡® base case -> æ˜ç¡®ã€ŒçŠ¶æ€ã€-> æ˜ç¡®ã€Œé€‰æ‹©ã€ -> å®šä¹‰ `dp` æ•°ç»„/å‡½æ•°çš„å«ä¹‰**ã€‚

åœ¨**æ˜ç¡®ã€Œé€‰æ‹©ã€**çš„æ€è€ƒæ˜¯å°±ä½“ç°å‡ºæ¥**â€œæ ‘â€**çš„å½±å­ï¼Œå¯ä»¥ç”»å‡ºæ ‘å½¢ç»“æ„æ¥è¾…åŠ©æ€è€ƒæœ€ä¼˜è§£çš„è·¯å¾„

é’ˆå¯¹æ¯é“é¢˜åº”è¯¥æœ‰çš„æ€è€ƒï¼š

1. **ç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰**
    dp[i]çš„å®šä¹‰ä¸ºï¼šç¬¬iä¸ªæ•°çš„æ–æ³¢é‚£å¥‘æ•°å€¼æ˜¯dp[i]

2. **ç¡®å®šé€’æ¨å…¬å¼**
    ä¸ºä»€ä¹ˆè¿™æ˜¯â¼€é“â¾®å¸¸ç®€å•çš„â¼Šâ»”é¢˜â½¬å‘¢ï¼Ÿ
    å› ä¸ºé¢˜â½¬å·²ç»æŠŠé€’æ¨å…¬å¼ç›´æ¥ç»™æˆ‘ä»¬äº†ï¼šçŠ¶æ€è½¬ç§»â½…ç¨‹ dp[i] = dp[i - 1] + dp[i - 2];

3. **dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ–**

   å¯¹äºå‰ææ‰€éœ€å…ƒç´ å¦‚ä½•è¿›è¡Œèµ‹å€¼ï¼›ä¾‹å¦‚çˆ¬æ¥¼æ¢¯ä¸æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­dp[0]ä¸dp[1]çš„èµ‹å€¼

4. **ç¡®å®šéå†é¡ºåº**
   ä»é€’å½’å…¬å¼dp[i] = dp[i - 1] + dp[i - 2];ä¸­å¯ä»¥çœ‹å‡ºï¼Œdp[i]æ˜¯ä¾èµ– dp[i - 1] å’Œ dp[i - 2]ï¼Œé‚£ä¹ˆéå†çš„é¡ºåº
   â¼€å®šæ˜¯ä»å‰åˆ°åéå†çš„

5. **ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„**

#### åŠ¨æ€è§„åˆ’ä¹¦å†™æ¡†æ¶

1.ç¡®å®šbase case

2.ç©·ä¸¾æ‰€æœ‰ç»“æœ

3.çŠ¶æ€è½¬ç§»

æ‘†è„±ç¼–ç¨‹çš„é»‘ç›’çŠ¶æ€ï¼šé¢˜ç›®åœ¨äºç²¾ï¼›éœ€è¦æ³¨æ„ï¼šæ¯é“é¢˜ä¸­**dp[]æ•°ç»„åŠå…¶ä¸‹æ ‡çš„å«ä¹‰**ã€**é€’æ¨å…¬å¼**ã€**dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ–**ã€**éå†é¡ºåº**ã€**æ‰“å°dpæ•°ç»„**ã€‚

åŠ¨æ€è§„åˆ’çš„éš¾ç‚¹æœ¬æ¥å°±åœ¨äºå¯»æ‰¾**æ­£ç¡®çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹**ï¼Œè®¾è®¡åŠ¨æ€è§„åˆ’çš„é€šç”¨æŠ€å·§ï¼š**æ•°å­¦å½’çº³æ€æƒ³**ã€‚

```python
# è‡ªé¡¶å‘ä¸‹é€’å½’çš„åŠ¨æ€è§„åˆ’
def dp(çŠ¶æ€1, çŠ¶æ€2, ...):
    for é€‰æ‹© in æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©:
        # æ­¤æ—¶çš„çŠ¶æ€å·²ç»å› ä¸ºåšäº†é€‰æ‹©è€Œæ”¹å˜
        result = æ±‚æœ€å€¼(result, dp(çŠ¶æ€1, çŠ¶æ€2, ...))
    return result

# è‡ªåº•å‘ä¸Šè¿­ä»£çš„åŠ¨æ€è§„åˆ’
# åˆå§‹åŒ– base case
dp[0][0][...] = base case
# è¿›è¡ŒçŠ¶æ€è½¬ç§»
for çŠ¶æ€1 in çŠ¶æ€1çš„æ‰€æœ‰å–å€¼ï¼š
    for çŠ¶æ€2 in çŠ¶æ€2çš„æ‰€æœ‰å–å€¼ï¼š
        for ...
            dp[çŠ¶æ€1][çŠ¶æ€2][...] = æ±‚æœ€å€¼(é€‰æ‹©1ï¼Œé€‰æ‹©2...)
```

#### æ–æ³¢é‚£å¥‘æ•°åˆ—

æ–æ³¢é‚£å¥‘æ•°åˆ—è¿™é“é¢˜â½¬æ˜¯â¾®å¸¸åŸºç¡€çš„é¢˜â½¬ï¼Œé€šå¸¸â½¤ F(n) è¡¨ç¤ºï¼Œå½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚è¯¥æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹ï¼Œåâ¾¯çš„æ¯â¼€é¡¹
æ•°å­—éƒ½æ˜¯å‰â¾¯ä¸¤é¡¹æ•°å­—çš„å’Œã€‚

```c++
class Solution {
public:
	int fib(int N) {
		if (N <= 1) return N;
		vector<int> dp(N + 1);
		dp[0] = 0;
		dp[1] = 1;
		for (int i = 2; i <= N; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[N];
	}
};
```

->æ—¶é—´å¤æ‚åº¦ï¼šO(n)
->ç©ºé—´å¤æ‚åº¦ï¼šO(n)

æ”¹è¿›ï¼š

```c++
class Solution {
public:
	int fib(int N) {
	if (N <= 1) return N;
	int dp[2];
	dp[0] = 0;
	dp[1] = 1;
	for (int i = 2; i <= N; i++) {
		int sum = dp[0] + dp[1];
		dp[0] = dp[1];
		dp[1] = sum;
	}
	return dp[1];
	}
};
```

->æ—¶é—´å¤æ‚åº¦ï¼šO(n)
->ç©ºé—´å¤æ‚åº¦ï¼šO(1)

#### çˆ¬æ¥¼æ¢¯

å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚

æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ

1. ç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰

dp[i]ï¼š **çˆ¬åˆ°ç¬¬iå±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i]ç§æ–¹æ³•**

â€‹	2.ç¡®å®šé€’æ¨å…¬å¼

å¦‚æœå¯ä»¥æ¨å‡ºdp[i]å‘¢ï¼Ÿ

ä»dp[i]çš„å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œdp[i] å¯ä»¥æœ‰ä¸¤ä¸ªæ–¹å‘æ¨å‡ºæ¥ã€‚

é¦–å…ˆæ˜¯**dp[i - 1]**ï¼Œä¸Ši-1å±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i - 1]ç§æ–¹æ³•ï¼Œé‚£ä¹ˆå†ä¸€æ­¥è·³ä¸€ä¸ªå°é˜¶ä¸å°±æ˜¯dp[i]äº†ä¹ˆã€‚

è¿˜æœ‰å°±æ˜¯**dp[i - 2]**ï¼Œä¸Ši-2å±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i - 2]ç§æ–¹æ³•ï¼Œé‚£ä¹ˆå†ä¸€æ­¥è·³ä¸¤ä¸ªå°é˜¶ä¸å°±æ˜¯dp[i]äº†ä¹ˆã€‚

é‚£ä¹ˆdp[i]å°±æ˜¯ dp[i - 1]ä¸dp[i - 2]ä¹‹å’Œï¼

æ‰€ä»¥dp[i] = dp[i - 1] + dp[i - 2] ã€‚

åœ¨æ¨å¯¼dp[i]çš„æ—¶å€™ï¼Œä¸€å®šè¦æ—¶åˆ»æƒ³ç€dp[i]çš„å®šä¹‰ï¼Œå¦åˆ™å®¹æ˜“è·‘åã€‚

è¿™ä½“ç°å‡ºç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰çš„é‡è¦æ€§ï¼

â€‹	3.dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ–

åœ¨å›é¡¾ä¸€ä¸‹dp[i]çš„å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬iå±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i]ä¸­æ–¹æ³•ã€‚

é‚£ä¹ˆiä¸º0ï¼Œdp[i]åº”è¯¥æ˜¯å¤šå°‘å‘¢ï¼Œè¿™ä¸ªå¯ä»¥æœ‰å¾ˆå¤šè§£é‡Šï¼Œä½†éƒ½åŸºæœ¬æ˜¯ç›´æ¥å¥”ç€ç­”æ¡ˆå»è§£é‡Šçš„ã€‚

ä¾‹å¦‚å¼ºè¡Œå®‰æ…°è‡ªå·±çˆ¬åˆ°ç¬¬0å±‚ï¼Œä¹Ÿæœ‰ä¸€ç§æ–¹æ³•ï¼Œä»€ä¹ˆéƒ½ä¸åšä¹Ÿå°±æ˜¯ä¸€ç§æ–¹æ³•å³ï¼šdp[0] = 1ï¼Œç›¸å½“äºç›´æ¥ç«™åœ¨æ¥¼é¡¶ã€‚

ä½†æ€»æœ‰ç‚¹ç‰µå¼ºçš„æˆåˆ†ã€‚

é‚£è¿˜è¿™ä¹ˆç†è§£å‘¢ï¼šæˆ‘å°±è®¤ä¸ºè·‘åˆ°ç¬¬0å±‚ï¼Œæ–¹æ³•å°±æ˜¯0å•Šï¼Œä¸€æ­¥åªèƒ½èµ°ä¸€ä¸ªå°é˜¶æˆ–è€…ä¸¤ä¸ªå°é˜¶ï¼Œç„¶è€Œæ¥¼å±‚æ˜¯0ï¼Œç›´æ¥ç«™æ¥¼é¡¶ä¸Šäº†ï¼Œå°±æ˜¯ä¸ç”¨æ–¹æ³•ï¼Œdp[0]å°±åº”è¯¥æ˜¯0.

**å…¶å®è¿™ä¹ˆäº‰è®ºä¸‹å»æ²¡æœ‰æ„ä¹‰ï¼Œå¤§éƒ¨åˆ†è§£é‡Šè¯´dp[0]åº”è¯¥ä¸º1çš„ç†ç”±å…¶å®æ˜¯å› ä¸ºdp[0]=1çš„è¯åœ¨é€’æ¨çš„è¿‡ç¨‹ä¸­iä»2å¼€å§‹éå†æœ¬é¢˜å°±èƒ½è¿‡ï¼Œç„¶åå°±å¾€ç»“æœä¸Šé å»è§£é‡Šdp[0] = 1**ã€‚

ä»dpæ•°ç»„å®šä¹‰çš„è§’åº¦ä¸Šæ¥è¯´ï¼Œdp[0] = 0 ä¹Ÿèƒ½è¯´å¾—é€šã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼šé¢˜ç›®ä¸­è¯´äº†næ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œé¢˜ç›®æ ¹æœ¬å°±æ²¡è¯´næœ‰ä¸º0çš„æƒ…å†µã€‚

æ‰€ä»¥æœ¬é¢˜å…¶å®å°±ä¸åº”è¯¥è®¨è®ºdp[0]çš„åˆå§‹åŒ–ï¼

æˆ‘ç›¸ä¿¡dp[1] = 1ï¼Œdp[2] = 2ï¼Œè¿™ä¸ªåˆå§‹åŒ–å¤§å®¶åº”è¯¥éƒ½æ²¡æœ‰äº‰è®®çš„ã€‚

æ‰€ä»¥æˆ‘çš„åŸåˆ™æ˜¯ï¼šä¸è€ƒè™‘dp[0]å¦‚æœåˆå§‹åŒ–ï¼Œåªåˆå§‹åŒ–dp[1] = 1ï¼Œdp[2] = 2ï¼Œç„¶åä»i = 3å¼€å§‹é€’æ¨ï¼Œè¿™æ ·æ‰ç¬¦åˆdp[i]çš„å®šä¹‰ã€‚

â€‹	4.ç¡®å®šéå†é¡ºåº

ä»é€’æ¨å…¬å¼dp[i] = dp[i - 1] + dp[i - 2];ä¸­å¯ä»¥çœ‹å‡ºï¼Œéå†é¡ºåºä¸€å®šæ˜¯ä»å‰å‘åéå†çš„

â€‹	5.ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„

```c++
class Solution {
public:
    int climbStairs(int n) {
        //1.dp[i]å«ä¹‰ï¼šè¾¾åˆ°ç¬¬ié˜¶å°é˜¶çš„æ–¹æ³•æ•°é‡ä¸ºdp[i]
        //2.ç¡®å®šé€’æ¨å…¬å¼dp[i] = dp[i-1] + dp[i-2]
        //3.åˆå§‹åŒ–:dp[0] = 1/0;dp[1] = 1,dp[2] = 2
        if(n <= 1) return n;
        //vector<int> dp(n + 1);
        int dp[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3;i <= n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];


    }
};
```

ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–

```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```

#### ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯

æ•°ç»„çš„æ¯ä¸ªä¸‹æ ‡ä½œä¸ºä¸€ä¸ªé˜¶æ¢¯ï¼Œç¬¬ i ä¸ªé˜¶æ¢¯å¯¹åº”ç€ä¸€ä¸ªéè´Ÿæ•°çš„ä½“åŠ›èŠ±è´¹å€¼ cost[i]ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚

æ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼ï¼Œä¸€æ—¦æ”¯ä»˜äº†ç›¸åº”çš„ä½“åŠ›å€¼ï¼Œä½ å°±å¯ä»¥é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªé˜¶æ¢¯æˆ–è€…çˆ¬ä¸¤ä¸ªé˜¶æ¢¯ã€‚

è¯·ä½ æ‰¾å‡ºè¾¾åˆ°æ¥¼å±‚é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚åœ¨å¼€å§‹æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ– 1 çš„å…ƒç´ ä½œä¸ºåˆå§‹é˜¶æ¢¯ã€‚

**æ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼ï¼Œä¸€æ—¦æ”¯ä»˜äº†ç›¸åº”çš„ä½“åŠ›å€¼ï¼Œä½ å°±å¯ä»¥é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªé˜¶æ¢¯æˆ–è€…çˆ¬ä¸¤ä¸ªé˜¶æ¢¯**.

**dp[i]çš„å®šä¹‰ï¼šåˆ°è¾¾ç¬¬iä¸ªå°é˜¶æ‰€èŠ±è´¹çš„æœ€å°‘ä½“åŠ›ä¸ºdp[i]**ã€‚dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];**æ³¨æ„è¿™é‡Œä¸ºä»€ä¹ˆæ˜¯åŠ cost[i]ï¼Œè€Œä¸æ˜¯cost[i-1],cost[i-2]ä¹‹ç±»çš„**ï¼Œå› ä¸ºé¢˜ç›®ä¸­è¯´äº†ï¼šæ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼.

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        // æ³¨æ„æœ€åä¸€æ­¥å¯ä»¥ç†è§£ä¸ºä¸ç”¨èŠ±è´¹ï¼Œæ‰€ä»¥å–å€’æ•°ç¬¬ä¸€æ­¥ï¼Œç¬¬äºŒæ­¥çš„æœ€å°‘å€¼
        return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
```

ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            int dpi = min(dp0, dp1) + cost[i];
            dp0 = dp1; // è®°å½•ä¸€ä¸‹å‰ä¸¤ä½
            dp1 = dpi;
        }
        return min(dp0, dp1);
    }
};
```

### èƒŒåŒ…é—®é¢˜

### æ‰“å®¶åŠ«èˆ

### è‚¡ç¥¨é—®é¢˜

### å­åºåˆ—é—®é¢˜

#### ä¸¤ç§æ€è·¯

**ç¬¬ä¸€ç§æ€è·¯æ¨¡æ¿æ˜¯ä¸€ä¸ªä¸€ç»´çš„ `dp` æ•°ç»„**

```Python
intÂ nÂ =Â array.length;
int[]Â dpÂ =Â newÂ int[n];

forÂ (intÂ iÂ =Â 1;Â iÂ <Â n;Â i++)Â {
Â Â Â Â forÂ (intÂ jÂ =Â 0;Â jÂ <Â i;Â j++)Â {
Â Â Â Â Â Â Â Â dp[i]Â =Â æœ€å€¼(dp[i],Â dp[j]Â +Â ...)
Â Â Â Â }
}
```

æ¯”å¦‚æˆ‘ä»¬å†™è¿‡çš„ [æœ€é•¿é€’å¢å­åºåˆ—](https://labuladong.github.io/article/fname.html?fname=åŠ¨æ€è§„åˆ’è®¾è®¡ï¼šæœ€é•¿é€’å¢å­åºåˆ—) å’Œ [æœ€å¤§å­æ•°ç»„å’Œ](https://labuladong.github.io/article/fname.html?fname=æœ€å¤§å­æ•°ç»„) éƒ½æ˜¯è¿™ä¸ªæ€è·¯ã€‚

åœ¨è¿™ä¸ªæ€è·¯ä¸­ `dp` æ•°ç»„çš„å®šä¹‰æ˜¯ï¼š

**åœ¨å­æ•°ç»„ `arr[0..i]` ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—ï¼ˆæœ€é•¿é€’å¢å­åºåˆ—ï¼‰çš„é•¿åº¦æ˜¯ `dp[i]`**ã€‚

**ç¬¬äºŒç§æ€è·¯æ¨¡æ¿æ˜¯ä¸€ä¸ªäºŒç»´çš„ `dp` æ•°ç»„**

```python
intÂ nÂ =Â arr.length;
int[][]Â dpÂ =Â newÂ dp[n][n];

forÂ (intÂ iÂ =Â 0;Â iÂ <Â n;Â i++)Â {
Â Â Â Â forÂ (intÂ jÂ =Â 0;Â jÂ <Â n;Â j++)Â {
Â Â Â Â Â Â Â Â ifÂ (arr[i]Â ==Â arr[j])Â 
Â Â Â Â Â Â Â Â Â Â Â Â dp[i][j]Â =Â dp[i][j]Â +Â ...
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â dp[i][j]Â =Â æœ€å€¼(...)
Â Â Â Â }
}
```

->**æ¶‰åŠä¸¤ä¸ªå­—ç¬¦ä¸²/æ•°ç»„çš„åœºæ™¯**ï¼Œ`dp` æ•°ç»„çš„å®šä¹‰å¦‚ä¸‹ï¼š

**åœ¨å­æ•°ç»„ `arr1[0..i]` å’Œå­æ•°ç»„ `arr2[0..j]` ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—é•¿åº¦ä¸º `dp[i][j]`**ã€‚

->**åªæ¶‰åŠä¸€ä¸ªå­—ç¬¦ä¸²/æ•°ç»„çš„åœºæ™¯**ï¼Œ`dp` æ•°ç»„çš„å®šä¹‰å¦‚ä¸‹ï¼š

**åœ¨å­æ•°ç»„ `array[i..j]` ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—çš„é•¿åº¦ä¸º `dp[i][j]`**ã€‚

## 

