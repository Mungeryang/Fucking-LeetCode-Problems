



# 数据结构与算法学习笔记——杨桂淼总结

**写在前面：**

2022.06.20漫长的暑假开始了，总要做些什么。做啥？——当然是做好本手儿（2022年高考学的词哈哈~）

付东来大哥的这本书是2022.03.26购入，那是大二下学期的开学后不久。一个学期囫囵吞枣的看了一遍，没有get到精髓部分，代码看着很明白，自己写着错误百出。于是计划利用好这个稍微漫长的暑假，认认真真学好数据结构与算法。

本总结是杨桂淼同学基于力扣平台的题目，参考付东来大哥的解题思路编写；东来大哥每道题都给出了基于Java的解题思路，但是目前阶段本人Java语言掌握一般。于是乎，借鉴东来大哥的思路，将题目全部运用python语言实现。随着本人的不断学习积累，完善后代码会全部开源到杨桂淼的GitHub仓库中，届时，欢迎各位大佬评阅斧正；欢迎各位志同道合的同志交流学习！

本人秉持东来大哥的理念——致力于把算法讲清楚！

参考引用文章来源：labuladong小站

计算机中数据结构的分类：

常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。

## 双指针技巧在链表与数组中的运用

双指针分类：1.**快慢指针** 2.**左右指针**

力扣中的对应题目如下：

数组：

| LeetCode                                                     | 力扣                                                         | 难度 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) | [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) | 🟠    |
| [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) | [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) | 🟢    |
| [27. Remove Element](https://leetcode.com/problems/remove-element/) | [27. 移除元素](https://leetcode.cn/problems/remove-element/) | 🟢    |
| [83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/) | [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) | 🟢    |
| [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) | 🟢    |
| [283. Move Zeroes](https://leetcode.com/problems/move-zeroes/) | [283. 移动零](https://leetcode.cn/problems/move-zeroes/)     | 🟢    |
| [344. Reverse String](https://leetcode.com/problems/reverse-string/) | [344. 反转字符串](https://leetcode.cn/problems/reverse-string/) | 🟢    |

在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：**左右指针**和**快慢指针**。

所谓左右指针，就是两个指针相向而行或者**相背而行**；而所谓快慢指针，就是两个指针**同向而行**，一快一慢。

对于单链表来说，大部分技巧都属于快慢指针。

在数组中并没有真正意义上的指针，但我们可以把**索引**当做数组中的指针，这样也可以在数组中施展双指针技巧，**本文先讲数组相关的双指针算法**，**再讲链表有关的双指针算法。**

### Array~快慢指针技巧

**数组问题中比较常见的快慢指针技巧，是让你原地修改数组**。

简单解释一下什么是原地修改：

如果不是原地修改的话，我们直接 new 一个 `int[]` 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。

但是现在题目让你原地删除，不允许 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。

由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到 `O(N^2)`。

高效解决这道题就要用到快慢指针技巧：

我们让慢指针 `slow` 走在后面，快指针 `fast` 走在前面**探路**，找到一个不重复的元素就赋值给 `slow` 并让 `slow` 前进一步。

这样，就保证了 `nums[0..slow]` 都是无重复的元素，当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是整个数组去重之后的结果。

```Python
//Java实现
int removeDuplicates(int[] nums){
    if (nums.length == 0)
    {
        return 0;
    }
    int slow = 0,fast = 0;
    while (fast < nums.length)
    {
        if (nums[fast] != nums[slow])
        {
            slow++;
            nums[slow] = nums[fast];
                
        }
        fast++; 
    }
    return slow + 1;
}
#python实现
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if(len(nums) == 0):
            return 0
        #can't assign to literal的错误来源是slow=0，fast=0写在了一行中
        #要么用逗号隔开，用么分成两行写
        slow=0
        fast=0
        while(fast < len(nums)):
            if(nums[fast] != nums[slow]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1

        return slow + 1
```

同理，将本题的思想用于链表去重的代码实现为：

```Python
ListNode deleteDuplicates(ListNode head) {
    if (head == null) return null;
    ListNode slow = head, fast = head;
    while (fast != null) {
        if (fast.val != slow.val) {
            // nums[slow] = nums[fast];
            slow.next = fast;
            // slow++;
            slow = slow.next;
        }
        // fast++
        fast = fast.next;
    }
    // 断开与后面重复元素的连接
    slow.next = null;
    return head;
}
```

类似的，例如力扣中的**移动零**题目：

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

本质就是数组去重后将尾巴部分元素改为0

```Python
class Solution(object):
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        #老套路，设置快慢指针
        slow=0
        fast=0
        #核心代码区，区分不同目标值的设置
        while(fast <len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        #与前面题唯一的不同点，是将数组去重后尾部元素修改为0，此处我用的for循环，有其他新方法欢迎大佬们修改提出意见
        for i in range(slow,len(nums)):
            nums[i] = 0
```

#### 数组移除元素

```python3
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow,fast = 0,0
        while(fast < len(nums)):
            if(nums[fast] != val):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

#### 移除数组中的重复元素

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow,fast = 0,0
        while(fast < len(nums)):
            if(nums[fast] != nums[slow]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return slow + 1
```

#### **去重的核心代码块**

```python
while(fast <len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
```

对于核心代码块而言，在熟练使用的情况下要记牢，方便后序写程序是效率提高。

### Array~左右指针技巧

#### 二分查找算法

|                           LeetCode                           |                             力扣                             | 难度 |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) |  🟠   |
| [704. Binary Search](https://leetcode.com/problems/binary-search/) | [704. 二分查找](https://leetcode.cn/problems/binary-search/) |  🟢   |

首先介绍以下二分查找的代码框架：

其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

**另外提前说明一下，计算 `mid` 时需要防止溢出**，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。

```java
def binarySearch(int[] nums, int target) {
    #设置左右指针
    int left = 0, right = ...;

    while(...) {
        #关键在mid值的设定与左右边界确定
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

二分查找并不简单，Knuth 大佬（著有大部头《计算机程序设计》一书，无数程序员的圣经）都说二分查找：**思路很简单，细节是魔鬼**。二分查找真正的坑根本就不是那些有关于溢出的细节问题，而是在于到底要给 `mid` 加一还是减一，while 里到底用 `<=` 还是 `<`。

几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。

我们要**深入细节**，比如不等号是否应该带等号，`mid` 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。

大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

从本书中学到了，在分析二分查找时，对于选择分支结构if-else很少使用，而是用**else if** 取代，这样可以展示二分查找的所有细节。

##### 寻找一个数

这段代码可以解决力扣第 704 题「 [二分查找](https://leetcode.cn/problems/binary-search/)」。

下面提出解决本题需要关注的细节：

**搜索一个元素时，搜索区间两端闭**；**while条件带等号**，否则需要打补丁。

if相等就返回，其他的是甭操心；**mid必须加减一**，因为区间两端闭。

while结束就凉凉，凄凄惨惨返-1.

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        left = 0
        right = len(nums)-1 #易错点
        while(left <= right):
            mid = left + (right - left)/2
            if(nums[mid] == target):
                return mid
            elif(nums[mid] < target):
                #对于mid的操作时二分查找的一个难点。
                left = mid + 1
            elif(nums[mid] > target):
                right = mid - 1
        return -1
```

**while(left <= right)的终止条件**是：left == right + 1->[right + 1,right]。

**while(left < right)的终止条件**是：left == right ->[left,right]。

##### 寻找左侧边界

左侧边界是左闭右开的搜索区间：**[left,right)**,因此需要注意while的条件是**while(left<right)**。

right = len(nums)



##### 寻找右侧边界

#### 反转系列与回文

回文模板：

```c++
bool isPalindrome(const string& s,int start,int end){
        for(int i = start,j = end;i < j;i++,j--){
            if(s[i] != s[j]){
                return false;
            }
        }
        return true;
```

##### 迭代反转单链表

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return head
        pre = None
        tmp = None
        #切记理解终止条件
        while(head != None):
            #迭代反转过程
            tmp = head.next
            head.next = pre
            pre = head
            head = tmp
        return pre
```

##### 递归反转单链表

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        #特殊情况
        if head == None or head.next == None:
            return head
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```

##### 回文链表

```python
#数组模拟
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        length = 0
        tmp = head
        while tmp: #求链表长度
            length += 1
            tmp = tmp.next
        
        result = [0] * length
        tmp = head
        index = 0
        while tmp: #链表元素加入数组
            result[index] = tmp.val
            index += 1
            tmp = tmp.next
        
        i, j = 0, length - 1
        while i < j: # 判断回文
            if result[i] != result[j]:
                return False
            i += 1
            j -= 1
        return True
        
#反转后半部分链表
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if head == None or head.next == None:
            return True
        slow, fast = head, head
        while fast and fast.next:
            pre = slow
            slow = slow.next
            fast = fast.next.next
        
        pre.next = None # 分割链表
        cur1 = head # 前半部分
        cur2 = self.reverseList(slow) # 反转后半部分，总链表长度如果是奇数，cur2比cur1多一个节点
        while cur1:
            if cur1.val != cur2.val:
                return False
            cur1 = cur1.next
            cur2 = cur2.next
        return True

    def reverseList(self, head: ListNode) -> ListNode:
        cur = head   
        pre = None
        while(cur!=None):
            temp = cur.next # 保存一下cur的下一个节点
            cur.next = pre # 反转
            pre = cur
            cur = temp
        return pre
```

##### **反转整数**

```python
class Solution:
    def reverse(self, x: int) -> int:
        if(x == 0):
            return 0
        if(x > 0):
            y = int(str(x)[::-1])
            return y if -2147483648<y<2147483647 else 0 
        if(x < 0):
            y = -int(str(abs(x))[::-1])
            return y if -2147483648<y<2147483647 else 0
```

##### **最长回文字符串**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ' '
        for i in range(len(s)):
            start = max(0,i-len(res)-1)
            tmp = s[start : i+1]
            #分情况：s中含有字母的个数
            if tmp == tmp[::-1]:
                res = tmp
            else:
                tmp = tmp[1:]
                if tmp == tmp[::-1]:
                    res = tmp
        return res
```

##### 反转字符串

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        
        # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(right//2)更低
        # 推荐该写法，更加通俗易懂
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

### Linked List~双指针技巧

链表：

| LeetCode                                                     | 力扣                                                         | 难度 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) | 🟠    |
| [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) | 🟢    |
| [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) | [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | 🔴    |
| [86. Partition List](https://leetcode.com/problems/partition-list/) | [86. 分隔链表](https://leetcode.cn/problems/partition-list/) | 🟠    |
| [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/) | 🟢    |
| [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) | [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) | 🟠    |
| [160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) | [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) | 🟢    |
| [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) | [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/) | 🟢    |

解决问题：

本节的难点在于，目前无法突破在力扣中对于**「虚拟头结点」**的建立使用。所以代码先按东哥Java实现，努力突破难点后，全部更新为python代码。

#### 设计链表-充分掌握

在链表类中实现这些功能：

-get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
-addAtHead(val)：在链表的第一个元素之前**添加**一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
-addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
-addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
-deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```python
# 单链表
class Node:
    
    def __init__(self, val):
        self.val = val
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head = Node(0)  # 虚拟头部节点
        self._count = 0  # 添加的节点数

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if 0 <= index < self._count:
            node = self._head
            for _ in range(index + 1):
                node = node.next
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self._count, val)

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index < 0:
            index = 0
        elif index > self._count:
            return

        # 计数累加
        self._count += 1

        add_node = Node(val)
        prev_node, current_node = None, self._head
        for _ in range(index + 1):
            prev_node, current_node = current_node, current_node.next
        else:
            prev_node.next, add_node.next = add_node, current_node

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if 0 <= index < self._count:
            # 计数-1
            self._count -= 1
            prev_node, current_node = None, self._head
            for _ in range(index + 1):
                prev_node, current_node = current_node, current_node.next
            else:
                prev_node.next, current_node.next = current_node.next, None


# 双链表
# 相对于单链表, Node新增了prev属性
class Node:
    
    def __init__(self, val):
        self.val = val
        self.prev = None
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head, self._tail = Node(0), Node(0)  # 虚拟节点
        self._head.next, self._tail.prev = self._tail, self._head
        self._count = 0  # 添加的节点数

    def _get_node(self, index: int) -> Node:
        # 当index小于_count//2时, 使用_head查找更快, 反之_tail更快
        if index >= self._count // 2:
            # 使用prev往前找
            node = self._tail
            for _ in range(self._count - index):
                node = node.prev
        else:
            # 使用next往后找
            node = self._head   
            for _ in range(index + 1):
                node = node.next
        return node

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if 0 <= index < self._count:
            node = self._get_node(index)
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self._update(self._head, self._head.next, val)

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self._update(self._tail.prev, self._tail, val)

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index < 0:
            index = 0
        elif index > self._count:
            return
        node = self._get_node(index)
        self._update(node.prev, node, val)

    def _update(self, prev: Node, next: Node, val: int) -> None:
        """
            更新节点
            :param prev: 相对于更新的前一个节点
            :param next: 相对于更新的后一个节点
            :param val:  要添加的节点值
        """
        # 计数累加
        self._count += 1
        node = Node(val)
        prev.next, next.prev = node, node
        node.prev, node.next = prev, next

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if 0 <= index < self._count:
            node = self._get_node(index)
            # 计数-1
            self._count -= 1
            node.prev.next, node.next.prev = node.next, node.prev

代码随想录：carlsun-2
```

#### 合并两个有序链表

这个算法的逻辑类似于拉拉链，两个需要合并的单链表，类似于拉链两侧的锯齿，指针 `p` 就好像拉链的拉索，将两个有序链表合并；过程与蛋白质的形成过程高度相似。（高中生物知识的复习）

运用的技巧：**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。如果不使用 `dummy` 虚拟节点，代码会复杂很多，而有了 `dummy` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。

```python
//java实现
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 虚拟头结点
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;

        while (p1 != null && p2 != null) {
            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p 指针不断前进
            p = p.next;
        }

        if (p1 != null) {
            p.next = p1;
        }

        if (p2 != null) {
            p.next = p2;
        }

        return dummy.next;
    }
}
```

运用递归方法实现合并：程序的可读性降低，但代码更简洁——递归思想后序总结，需要掌握好！

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def mergeTwoLists(self, list1, list2):
        """
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        if not list1: return list2
        if not list2: return list1
        if(list1.val <= list2.val):
            #递归核心
            list1.next = self.mergeTwoLists(list1.next,list2)
            return list1
        else:
            #递归核心
            list2.next = self.mergeTwoLists(list1,list2.next)
            return list2
```

#### 链表的分解

在合并两个有序链表时让你合二为一，而这里需要分解让你把原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 `x`，另一个链表中的元素都大于等于 `x`，最后再把这两条链表接到一起，就得到了题目想要的结果。

3、合并 `k` 个有序链表

合并 `k` 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 `k` 个节点中的最小节点，接到结果链表上？

这里我们就要用到 [优先级队列（二叉堆）](https://labuladong.gitee.io/algo/2/21/62/) 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 `k` 个节点中的最小节点：

```python
ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) return null;
    // 虚拟头结点
    ListNode dummy = new ListNode(-1);
    ListNode p = dummy;
    // 优先级队列，最小堆
    PriorityQueue<ListNode> pq = new PriorityQueue<>(
        lists.length, (a, b)->(a.val - b.val));
    // 将 k 个链表的头结点加入最小堆
    for (ListNode head : lists) {
        if (head != null)
            pq.add(head);
    }

    while (!pq.isEmpty()) {
        // 获取最小节点，接到结果链表中
        ListNode node = pq.poll();
        p.next = node;
        if (node.next != null) {
            pq.add(node.next);
        }
        // p 指针不断前进
        p = p.next;
    }
    return dummy.next;
}
```

这个算法是面试常考题，它的时间复杂度:

优先队列 `pq` 中的元素个数最多是 `k`，所以一次 `poll` 或者 `add` 方法的时间复杂度是 `O(logk)`；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 `O(Nlogk)`，其中 `k` 是链表的条数，`N` 是这些链表的节点总数**。

#### 寻找单链表的中点

力扣第 876 题「 [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 `n`，常规方法也是先遍历链表计算 `n`，再遍历一次得到第 `n / 2` 个节点，也就是中间节点。

如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：

我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。

**每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样，当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def middleNode(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        #快慢指针初始化指向 head
        slow = head
        fast = head
        while(fast != None and fast.next != None):
            slow = slow.next
            fast = fast.next.next
        return slow
```

#### 寻找单链表的倒数第 `k` 个节点

以下是东哥文章中的详细解题思路：

从前往后寻找单链表的第 `k` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 `k` 个节点呢？

那你可能说，假设链表有 `n` 个节点，倒数第 `k` 个节点就是正数第 `n - k + 1` 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 `ListNode` 头结点代表一条单链表，你不能直接得出这条链表的长度 `n`，而需要先遍历一遍链表算出 `n` 的值，然后再遍历链表计算第 `n - k + 1` 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 `k` 个节点

那么，我们能不能**只遍历一次链表**，就算出倒数第 `k` 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 `k = 2`，思路如下：

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

现在的 `p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`：

接下来就很显然了，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head` 开始前进了 `n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第 `k` 个节点上：

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

东哥很详细地说了一大堆，其实简单总结起来就是：**先利用for循环让快指针先走k步，在利用上题寻找中点思路即可解决。**

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getKthFromEnd(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        slow = head
        fast = head
        #先让快指针fast向前走k步
        for i in range(k):
            fast = fast.next
        #while(fast != None and fast.next != None)多加一个fast的next的结果为[3,4,5]与原题结果不符合;注意条件控制
        while(fast != None):
            slow = slow.next
            fast = fast.next
        return slow
```

#### 判断单链表是否包含环并找出环起点

经典问题的解决方案仍然是：快慢指针。每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。只需要把寻找链表中点的代码稍加修改就行了：

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        slow = head
        fast = head
        #寻找中点的套路
        while(fast != None and fast.next != None):
            #快指针前进两步
            fast = head.next.next
            #慢指针前进一步
            slow = head.next
            #当快指针比慢指针多走一圈时，相遇便成环
            if(fast == slow):
                return True
        return False
#不知道为啥这个代码总是运行超时，是时间复杂度太大吗？-2022.06.21
```

#### 判断两个单链表是否相交并找出交点

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点 `c1`。

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`**。

所以，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`

```Python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        p1 = headA
        p2 = headB
        while(p1 != p2):
            #p1 走一步，如果走到 A 链表末尾，转到 B 链表
            if(p1 == None):
                p1 = headB
            else:
                p1 = p1.next
            #p2 走一步，如果走到 B 链表末尾，转到 A 链表
            if(p2 == None):
                p2 = headA
            else:
                p2 = p2.next
        return p1
```

## 滑动窗口

双指针运用最难得部分！

|                           LeetCode                           |                             力扣                             | 难度 |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) |  🟠   |
| [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/) | [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) |  🟠   |
| [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/) | [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/) |  🟠   |
| [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/) | [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) |  🔴   |
|                              -                               | [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/) |  🟠   |
|                              -                               | [剑指 Offer II 014. 字符串中的变位词](https://leetcode.cn/problems/MPnaiL/) |  🟠   |
|                              -                               | [剑指 Offer II 015. 字符串中的所有变位词](https://leetcode.cn/problems/VabMRr/) |  🟠   |
|                              -                               | [剑指 Offer II 016. 不含重复字符的最长子字符串](https://leetcode.cn/problems/wtcaE1/) |  🟠   |
|                              -                               | [剑指 Offer II 017. 含有所有字符的最短字符串](https://leetcode.cn/problems/M1oyTv/) |  🔴   |

题目特点：

**最长/最短->子数组、子序列、子串**

解决一类最难掌握的双指针技巧：**滑动窗口技巧**；这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。

这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。

其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。

框架：

```java
/* 滑动窗口算法框架 */
void slidingWindow(string s) {
    unordered_map<char, int> window;
    
    int left = 0, right = 0;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

**其中两处 `...` 表示的更新窗口数据的地方，到时候你直接往里面填就行了**；而且，这两个 `...` 处的操作分别是扩大和缩小窗口的更新操作。

在处理字符串反面，c/c++要比Java有优势。

**滑动窗口算法的思路**：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是**最方便处理**的。因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动（扩大）一位，区间 `[0, 1)` 就包含一个元素 `0` 了。如果你设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

#### 长度最小子数组

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 

```python
class Solution(object):
    def minSubArrayLen(self, target, nums):
        """
        :type target: int
        :type nums: List[int]
        :rtype: int
        """
        #判断极端情况
        if len(nums) == 0:
            return 0
        #确定最值
        res = len(nums) + 1
        s = 0
        #定义双指针
        right = left = 0
        #扩大窗口
        while(right < len(nums)):
            s = s + nums[right]
            right += 1
            #比较目标值，扩大窗口的终止条件
            while s >= target:
                #righ-left为窗口内的元素
                res = min(res,right-left)
                #从左侧缩小窗口
                s = s - nums[left]
                left += 1
        #所有元素的和小于target
        if res == len(nums)+1:
            return 0
        #符合条件输出
        else:
            return res
```

#### 无重复字符的最长子串

```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        #极端条件判断
        if len(s) == 0:
            return 0
        #定义所需变量
        left = count = res = 0
        #遍历列表的时间复杂度是O（n），遍历集合的时间复杂度是O（1）
        windows = set()
        #有指针依次向后遍历
        for i in range(len(s)):
            #计数
            count += 1
            #右指针指向元素已经在窗口中，即出现重复元素
            while s[i] in windows:
                #缩小窗口
                windows.remove(s[left])
                count -= 1
                left += 1
            #保留最值
            res = max(res,count)
            #窗口右侧加入元素
            windows.add(s[i])
        #返回结果
        return res
```

#### 乘积小于K的子数组

```python
class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        #特殊情况
        if k <= 1:
            return 0
        #双指针
        left = 0
        right = 0
        #记录器与计数器
        res = 1
        result = 0
        #扩大窗口
        while right < len(nums):
            res *= nums[right]
            #缩小窗口
            while res >= k:
                res /= nums[left]
                left += 1
            result += (right-left+1)
            right += 1
        return result
```

#### 最大连续1的个数

```Python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        #设置双指针
        left = 0
        right = 0
        #记录器和计数器
        res = 0
        count = 0
        while right < len(nums):
            #扩大窗口
            if nums[right] == 0:
                count += 1
            right += 1
            #缩小窗口
            if count > k:
                if nums[left] == 0:
                    count -= 1
                left += 1
            res = max(res,right - left)
        return res
```



## 二叉树

视频导学：

[二叉树/递归的框架思维（纲领篇）](https://www.bilibili.com/video/BV1nG411x77H?spm_id_from=333.337.search-card.all.click&vd_source=f093c3d64ba399e149cbffa6cd31a7b0)

**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 [回溯算法核心框架](https://labuladong.gitee.io/algo/4/30/104/) 和 [动态规划核心框架](https://labuladong.gitee.io/algo/3/24/67/)**。二叉树模型几乎是所有高级算法的基础，尤其是那么多人说对递归的理解不到位，更应该好好刷二叉树相关题目。

2022.08.28添加：对于递归函数书写的一些**新的思考与启发**

学习本部分主要是学会使用递归函数的书写逻辑：

再次温习一下之前学过的**递归三部曲**：

1.递归函数的参数和返回值的设置

比如在在写回溯函数时，函数参数需要自己去定义。此时就要考虑，那些参数是我需要的，那些参数是题目中已知的；自定义的这个函数的类型是什么：viod泛型？bool型？int型？

```c++
void traverse(参数1，参数2....){
    
}
```

2.终止条件

多数情况下就是遍历到树的根节点后开始返回；

```c++
if(rooot == NULL){
	return;
}
```

3.递归的逻辑

在终止条件之后紧接着就是递归函数的调用；绝大多数递归的逻辑是前序逻辑，题目让干啥咱就干啥，而且递归的顺序一般就是先左子树后右子树，从上到下的DFS。

```c++
//前序操作（看题目要求）
traverse(root->left,....);
traverse(root->right,....);
```

对于大多数的算法，暴力解决是可以的；但是无数个for循环嵌套既浪费时间又浪费空间，当情况较复杂是，for循环嵌套必定会出错。而递归回溯函数的书写，就是让计算机自己去深处遍历迭代，空间时间都可节省，可谓是计算机思维的精髓之处。

树既有递归遍历又有迭代遍历，在迭代遍历时一定要注意while循环的终止条件，一般是当节点不为空时，终止循环while；即：**while(!=root)**

### 二叉树-纲领篇

|                           LeetCode                           |                             力扣                             | 难度 |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) |  🟢   |
| [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) | [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) |  🟢   |
| [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) | [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) |  🟢   |
|                              -                               | [剑指 Offer 55 - I. 二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/) |  🟢   |

总的老说，二叉树的两种解决思路：
1.遍历->回溯问题->前序操作
2.分解->动规问题->后序操作

遇到一道二叉树的题目时的通用思考过程是：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

**3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。

二叉树的框架思维：

```Java
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
```

以数组和链表为例，看遍历和分解的区别与联系：

```python
/* 迭代遍历数组 */
#void traverse(int[] arr) {
    #for (int i = 0; i < arr.length; i++) {

    #}
#}
def traverse(int[] arr):
	for i in range(len(arr)):
	

/* 递归遍历数组 */
#void traverse(int[] arr, int i) {
    #if (i == arr.length) {
        #return;
    #}
    #// 前序位置
    #traverse(arr, i + 1);
    #// 后序位置
#}
def traverse(int[] arr, int i):
	if (i == len(arr)):
		return
		
	// 前序位置
    traverse(arr, i + 1);
    // 后序位置

/* 迭代遍历单链表 */
#void traverse(ListNode head) {
    #for (ListNode p = head; p != null; p = p.next) {

    #}
#}
def traverse(ListNode head):
	p = head
	while(p != None and p.next != None):
		p = p.next

/* 递归遍历单链表 */
#void traverse(ListNode head) {
    #if (head == null) {
        #return;
    #}
    #// 前序位置
    #traverse(head.next);
    #// 后序位置
#}
def traverse(ListNode head):
	if (head == None):
		return
		
	// 前序位置
    traverse(head.next);
    // 后序位置
```

递归三部曲：

递归函数的参数返回值

终止条件

递归的逻辑

#### 二叉树的最大深度

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        #分解问题：先找左右子树的最大深度然后加一-动态规划思路(后序位置操作)
        #递归到根节点
        if(root == None):
            return 0
        
        leftmax = self.maxDepth(root.left)
        rightmax = self.maxDepth(root.right)
        #推到原二叉树的最大深度
        return max(leftmax,rightmax) + 1
```

```java
#回溯思路
    class Solution {

    int depth = 0;
    int res = 0;

    public int maxDepth(TreeNode root) {
        traverse(root);
        return res;
    }

    // 遍历二叉树
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        // 前序遍历位置
        depth++;
        // 遍历的过程中记录最大深度
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // 后序遍历位置
        depth--;
    }
}
```

#### 二叉树最小深度

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        if not root.left and not root.right:
            return 1

        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth) # 获得左子树的最小高度
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth) # 获得右子树的最小高度
        return min_depth + 1
```

#### 二叉树的遍历

##### 前序遍历

递归解法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
#递归解法
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def preorder(root: TreeNode):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)
        
        res = list()
        preorder(root)
        return res
  
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #保存结果
        res = []

        #定义遍历函数
        def traversal(root):
            #根节点判断
            if root == None:
                return
            res.append(root.val)
            traversal(root.left)
            traversal(root.right)
        
        traversal(root)
        return res
```

迭代解法

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        if not root:
            return res
        
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res
```

##### 中序遍历

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #保存结果
        res = []

        def traervsal(root):
            #根节点判断
            if root == None:
                return
            #递归遍历
            traervsal(root.left)
            #中序操作
            res.append(root.val)
            traervsal(root.right)
        traervsal(root)
        return res
```

##### 后序遍历

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #保存结果
        res = []

        #定义遍历函数
        def traversal(root):
            if root == None:
                return
            traversal(root.left)
            traversal(root.right)
            #后序操作
            res.append(root.val)
        traversal(root)
        return res
```

#### 二叉树的最大直径

后序遍历

```python
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1
        def depth(node):
            # 访问到空节点了，返回0
            if not node:
                return 0
            # 左孩子为根的子树的深度
            L = depth(node.left)
            # 右孩子为根的子树的深度
            R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
            self.ans = max(self.ans, L + R + 1)
            # 返回该节点为根的子树的深度
            return max(L, R) + 1

        depth(root)
        return self.ans - 1
```

#### 二叉树的层序遍历

层序遍历就是从左到右一层一层去遍历二叉树。需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上**[[1]](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)

##### 层序遍历

```python
#层序遍历迭代法：
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        results = []
        if not root:
            return results
        
        from collections import deque
        que = deque([root])
        
        while que:
            size = len(que)
            result = []
            for _ in range(size):
                cur = que.popleft()
                result.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            results.append(result)

        return results
    
  
#层序遍历递归法
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        res = []
        def cengxu(root,depth):
            if not root:
                return []
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            if root.left:
                cengxu(root.left,depth+1)
            if root.right:
                cengxu(root.right,depth+1)
        cengxu(root,0)
        return res
   
#[[3],[9,20],[15,7]]最后的结果是列表的嵌套

#自底向上层序遍历
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        #记录结果
        res = []
        #定义层序遍历函数
        def cengxu(root,depth):
            #根节点判断
            if not root:
                return None
            #一开始很不理解这一步
            #观察结果:[[15,7],[9,20],[3]]；涉及到列表的嵌套
            #每当深度加一,就要增加一个子列表
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            if root.left:
                cengxu(root.left,depth + 1)
            if root.right:
                cengxu(root.right,depth + 1)
        cengxu(root,0)
        return res[::-1]
```

##### 二叉树的右视图

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        #结果记录
        res = []
        #定义层序遍历函数
        def cengxu(root,depth):
            if not root:
                return None
            if len(res) == depth:
                res.append(root.val)
            #res[depth].append(root.val)
            #只去遍历右子树-准确来说是去遍历每个节点的右子树
            if root.right:
                cengxu(root.right,depth + 1)
            if root.left:
                cengxu(root.left,depth + 1)
        cengxu(root,0)
        return res
```

##### 计算二叉树每层节点的平均数

```Python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def averageOfLevels(self, root):
        """
        :type root: TreeNode
        :rtype: List[float]
        """
        #保存结果
        res = []
        ans = []
        #定义层序遍历函数
        def cengxu(root,depth):
            if not root:
                return None
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            #遍历左右子树
            if root.left:
                cengxu(root.left,depth + 1)
            if root.right:
                cengxu(root.right,depth + 1)
        cengxu(root,0)
        for i in range(len(res)):
            sum1 = sum(res[i])
            num = len(res[i])
            ans.append(sum1 / num)
        return ans
```



### 二叉树-思路篇

层序遍历+栈就是后序遍历结果

刷完上面纲领篇幅的一些体会：

二叉树重要的部分：框架+细节；框架主要是对递归函数的书写，细节就是-前序遍历OR后序遍历-代码的摆放**位置**

|                           LeetCode                           |                             力扣                             | 难度 |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
| [114. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) | [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) |  🟠   |
| [116. Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) | [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) |  🟠   |
| [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) | [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) |  🟢   |
|                              -                               | [剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/) |  🟢   |

#### 反转二叉树

反转的思想就是借助tmp指针进行左右节点的交换

分解问题思路：

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        #判断根节点
        if root == None:
            return
            
        #分解问题的思路
        self.invertTree(root.left)
        self.invertTree(root.right)

        tmp = root.left
        root.left = root.right
        root.right = tmp
        return root
```

回溯思路：

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        self.traverse(root)
        return root
        
    def traverse(self, root):
        if root == None:
            return
        #前序位置
        tmp = root.left
        root.left = root.right
        root.right = tmp
        #遍历框架，去遍历左右子树的节点
        self.traverse(root.left)
        self.traverse(root.right)
```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        /*
        //终止节点判断
        //从上到下递归遍历
        if(root == NULL) return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
        */
        //迭代遍历
        if(root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            swap(node->left,node->right);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);

        }
        return root;

    }
};
```

#### 对称二叉树

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        return self.compare(root.left, root.right)
        
    def compare(self, left, right):
        #对称二叉树的条件
        if left != None and right == None:
            return False
        elif left == None and right != None:
            return False
        elif left == None and right == None:
            return True
        elif left.val != right.val:
            return False
        #此时就是左右节点相同进入下一层遍历
        ots = self.compare(left.left,right.right)
        ins = self.compare(left.right,right.left)
        isSymmetric = ots and ins
        return isSymmetric
```

#### 填充每个节点的下一个右侧节点指针

前序遍历：

前序遍历时要定义一个traverse函数用于递归前序节点。

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution(object):
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        #根节点情况
        if root == None:
            return
        self.traverse(root.left,root.right)
        return root
    def traverse(self,node1,node2):
        if node1 == None and node2 == None:
            return
        #连接传入的两个节点
        node1.next = node2
        #前序遍历
        self.traverse(node1.left,node1.right)
        self.traverse(node2.left,node2.right)
        self.traverse(node1.right,node2.left)
```

#### 将二叉树展开为链表

首先通过遍历寻求解题思路：发现遍历虽然得到了前序遍历结果但是无法把原来的二叉树拉平为一个链表

因此寻求分解问题的解决方法：先拉平左子树，在拉平右子树；最后将右子树嫁接到左子树上即可完成。

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        #根节点操作
        if root == None:
            return 
        #拉平左右子树
        self.flatten(root.left)
        self.flatten(root.right)
        #后序操作:分别将子树拉平为链表
        l = root.left
        r = root.right
        #将左子树作为右子树
        root.left = None
        root.right = l
        #将原先的右子树接到当前右子树的末端
        p = root
        while(p.right != None):
            p = p.right
        p.right = r
```

#### 左叶子之和

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        #根节点判断
        if not root: 
            return 0
        
        left_left_leaves_sum = self.sumOfLeftLeaves(root.left)  # 左
        right_left_leaves_sum = self.sumOfLeftLeaves(root.right) # 右
        
        cur_val = 0
        if root.left and not root.left.left and not root.left.right: 
            cur_val = root.left.val  # 中
            
        return cur_val + left_left_leaves_sum + right_left_leaves_sum
```



### 二叉树-构造篇

每日一遍解题思路：

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

#### 最大二叉树

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        #先找到最大值与其对应的索引 根节点 
        maxvalue = max(nums)
        index = nums.index(maxvalue)
        #将最大值确定为父节点 根节点 
        root = TreeNode(maxvalue)
        #前序操作划分左右子树  构造左子树 + 构造右子树
        left = nums[:index]
        right = nums[index + 1:]
        #递归遍历
        root.left = self.constructMaximumBinaryTree(left)
        root.right = self.constructMaximumBinaryTree(right)
        return root
```

#### 通过前序和中序遍历结果构造二叉树

**我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可**。

前序遍历和中序遍历的结果有什么特点：

```Java
void traverse(TreeNode root) {
    // 前序遍历
    preorder.add(root.val);
    traverse(root.left);
    traverse(root.right);
}

void traverse(TreeNode root) {
    traverse(root.left);
    // 中序遍历
    inorder.add(root.val);
    traverse(root.right);
```

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。

关键在于如何通过根节点的值，将 `preorder` 和 `postorder` 数组划分成两半，构造根节点的左右子树？

换句话说，对于以下代码中的 `?` 部分应该填入什么：

```java
/* 主函数 */
public TreeNode buildTree(int[] preorder, int[] inorder) {
    // 根据函数定义，用 preorder 和 inorder 构造二叉树
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1);
}

/* 
    build 函数的定义：
    若前序遍历数组为 preorder[preStart..preEnd]，
    中序遍历数组为 inorder[inStart..inEnd]，
    构造二叉树，返回该二叉树的根节点 
*/
TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }

    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, ?, ?,
                      inorder, ?, ?);

    root.right = build(preorder, ?, ?,
                       inorder, ?, ?);
    return root;
}
```

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        #树为空，进行递归终止
        if not preorder:
            return None
        
        #找到并构造根节点
        rootval = preorder[0]
        root = TreeNode(rootval)
        #从中序遍历切割
        index = inorder.index(rootval)
        inleft = inorder[:index]
        inright = inorder[index + 1:]
        #重点：切割前序数组：注意子数组大小一定保持不变
        preleft = preorder[1:1+len(inleft)]
        preright = preorder[len(inleft)+1:]
        #递归
        root.left = self.buildTree(preleft,inleft)
        root.right = self.buildTree(preright,inright)
        return root
```

#### 从中序与后序遍历序列构造二叉树

```Python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        #特殊情况判断
        if not postorder:
            return None
        #找到并构建根节点
        rootval = postorder[-1]
        root = TreeNode(rootval)
        #中序数组在确定位置并切割数组
        index = inorder.index(rootval)
        inleft = inorder[:index]
        inright = inorder[index+1:]
        #重点是后序数组切割大小
        poleft = postorder[:len(inleft)]
        poright = postorder[len(inleft):len(postorder)-1]
        #递归
        root.left = self.buildTree(inleft,poleft)
        root.right = self.buildTree(inright,poright)
        return root
```

#### 完全二叉树节点个数

```python
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        return self.getNodesNum(root)
        
    def getNodesNum(self, cur):
        if not cur:
            return 0
        leftNum = self.getNodesNum(cur.left) #左
        rightNum = self.getNodesNum(cur.right) #右
        treeNum = leftNum + rightNum + 1 #中
        return treeNum
   
#简化版
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```

#### 平衡二叉树

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if self.get_height(root) != -1:
            return True
        else:
            return False
    
    def get_height(self, root: TreeNode) -> int:
        # Base Case
        if not root:
            return 0
        # 左
        if (left_height := self.get_height(root.left)) == -1:
            return -1
        # 右
        if (right_height := self.get_height(root.right)) == -1:
            return -1
        # 中
        if abs(left_height - right_height) > 1:
            return -1
        else:
            return 1 + max(left_height, right_height)
```

#### 二叉树的路径

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        path = ''
        res = []
        if not root:
            return res
        self.road(root,path,res)
        return res

    #定义遍历函数 
    def road(self,cur,path,res):
        #路径表示
        path += str(cur.val)
        #叶子结点判断
        if not cur.left and not cur.right:
            res.append(path)
        #递归左右子树
        if cur.left:
            self.road(cur.left,path + '->',res)
        if cur.right:
            self.road(cur.right,path + '->',res)
```

#### 二叉树减枝

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        //判断空值
        if(!root){
            return nullptr;
        }
        //递归左右子树
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        //判断根节点
        if(root->val == 0 && !root->left && !root->right){
            return nullptr;
        }
        return root;
    }
};
```

#### 最大二叉树

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。
链接：https://leetcode.cn/problems/maximum-binary-tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* node = new TreeNode(0);
        if (nums.size() == 1) {
            node->val = nums[0];
            return node;
        }
        // 找到数组中最大的值和对应的下表
        int maxValue = 0;
        int maxValueIndex = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }
        node->val = maxValue;
        // 最大值所在的下表左区间 构造左子树
        if (maxValueIndex > 0) {
            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
            node->left = constructMaximumBinaryTree(newVec);
        }
        // 最大值所在的下表右区间 构造右子树
        if (maxValueIndex < (nums.size() - 1)) {
            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = constructMaximumBinaryTree(newVec);
        }
        return node;
    }
};

//优化遍历代码
class Solution {
private:
    // 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // 分割点下表：maxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // 左闭右开：[left, maxValueIndex)
        root->left = traversal(nums, left, maxValueIndex);

        // 左闭右开：[maxValueIndex + 1, right)
        root->right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```



#### 合并二叉树

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点
链接：https://leetcode.cn/problems/merge-two-binary-trees

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //终止条件
        if(root1 == NULL) return root2;
        if(root2 == NULL) return root1;
        //单层递归的逻辑
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left,root2->left);
        root1->right = mergeTrees(root1->right,root2->right);
        return root1;

    }
};
```

### 二叉树-后序篇

后序遍历二叉树是一种自底向上的遍历过程；后序遍历思想在回溯算法中应用最为广泛，本质就是一棵树先从上到下不操作，一撸到底，然后从叶子结点开始，向上根节点回溯的过程；说白了也就是递归的逆过程。

为什么都是后序遍历呢？这是一个值得思考的问题。

用剪枝的思想，去类比问题。无论是寻找最大直径、最长相同路径还是最大路径和，本质上都是一个从树的底部向树的顶部（root）去剪枝优化的过程。其实剪枝说的不准确，但是剪枝的目的也是寻找最优路径的选取过程。始终记住，后序是因为自底向上寻找的思路，那么这些问题就可以总结出一个很好模板思路。

#### 二叉树的最大直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //后序遍历如何用？
 //遍历函数怎么写？
 //返回值是什么？
 //终止条件是什么？
 //单层遍历的逻辑是什么？
class Solution {
private:
    //int ans = 1;
    //dfs深度优先
    //函数定义的类型一定要和返回值密切相关。
    int travseral(TreeNode* node){
        //终止条件就是向下遍历到根节点
        if(node == NULL){
            return 0;
        }
        return max(travseral(node->left),travseral(node->right)) + 1;

    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        if(root == NULL) return 0;
        //定义左右子树之间的最大值
        int cur = travseral(root->left) + travseral(root->right);
        //diameterOfBinaryTree函数是返回左右子树自身的最大值
        //最后返回的是左右子树、左子树自身、右子树自身三者之间的最大值
        return max({cur,diameterOfBinaryTree(root->left),diameterOfBinaryTree(root->right)});

    }
};
```

#### 最长同值路径

给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。

两个节点之间的路径长度 由它们之间的边数表示。
链接：https://leetcode.cn/problems/longest-univalue-path

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int res = 0;
    //遍历函数时什么、返回值是什么？
    int dfs(TreeNode* root,int parentVal){
        //终止条件
        if(root == NULL){
            return 0;
        }
        // 利用函数定义，计算左右子树值为 root.val 的最长树枝长度
        int left = dfs(root->left,root->val);
        int right = dfs(root->right,root->val);

        //后序操作:直接返回左右子树最大路径之和
        res = max(res, left + right);
        // 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝
        if(root->val != parentVal){
            //注意返回值的设定
            return 0;
        }
        // 实现函数的定义：
        // 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度
        // 等于左右子树的最长树枝长度的最大值加上 root 节点本身
        return 1 + max(left,right);


    }
public:
    int longestUnivaluePath(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        dfs(root,root->val);
        return res;

    }
};
```

#### 二叉树中最大路径和

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。
链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:

    int ret = INT_MIN;
    //函数定义和返回值是什么？
    // 定义：计算从根节点 root 为起点的最大单边路径和
    int dfs(TreeNode* root){
        //终止条件
        if(root == NULL){
            return 0;
        }
        int leftsum = max(0,dfs(root->left));
        int rightsum = max(0,dfs(root->right));
        // 后序遍历位置，顺便更新最大路径和
        int pathsum = root->val + leftsum + rightsum;
        ret = max(ret,pathsum);
        // 实现函数定义，左右子树的最大单边路径和加上根节点的值
        // 就是从根节点 root 为起点的最大单边路径和
        return max(leftsum,rightsum) + root->val;

    }
public:
    int maxPathSum(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        dfs(root);
        return ret;

    }
};
```



### 二叉搜索树

二叉搜索树的基本概念：

二叉搜索树是一颗有序树，满足如下规则：

 * 若它的左子树不空，则左子树上所有节点的值都小于它的根节点上的值。
 * 若它的右子树不空，则右子树上所有节点的值都大于它的根节点上的值。
 * 它的左右子树也分别书二叉排序树。

二叉搜索树的**中序遍历**是一个严格的**递增序列**。所有在遇到二叉搜索树的相关问题时，巧用**中序遍历**是解题的关键也是解决问题的快速方法。

中序遍历代码：

```c++
void searchBST(TreeNode* cur){
    if(cur == NULL) return;
    searchBST(root->left);//左
    (中序操作)
    searchBST(root->right);//右
}
```

在解决二叉搜索树的最值问题时，递归可以采用两种基本的方式：

1.以**数组**为基本数据结构的方式

思路：

以数组为基本的存储方式中序遍历写起来较为直观

```c++
vector<int> res;
void travser(TreeNode* root){
        if(root == NULL) return;
        travser(root->left);
        res.push_back(root->val);
        travser(root->right);
```

操作是放在**主函数**中进行，在主函数利用for循环进行求解最值得问题；**中序遍历**的方法只是为了得到一个**升序的数组**，得以把一颗二叉排序树转化成一个单调递增的数组，以方便处理。

2.以**单链表**为基本数据结构的方式

思路：

单链表的方式需要设置两个节点指针：**cur和pre**，相当于一个头指针和一个尾指针；无论是在迭代还是在递归中，头尾指针的设定就是去摆脱在主函数中的二次for循环操作，而降低时间复杂度，在递归的过程中即实现操作的一步到位。

```c++
TreeNode* pur = NULL;//记录前一个节点
//TreeNode* cur = root;
if(root == NULL) return true;
//中序遍历思路
bool left = isValidBST(root->left);
//相当于是中序遍历操作中在操作的判断
//运用头结点pur判断是否是一个递增的序列
if(pur != NULL && pur->val >= root->val) return false;
pur = root;
bool right = isValidBST(root->right);
//相当于中序遍历多加了一个if判断操作
```

#### 在二叉搜索树中寻找节点

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
链接：https://leetcode.cn/problems/search-in-a-binary-search-tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //确定递归函数和参数设置
    TreeNode* searchBST(TreeNode* root, int val) {
        //终止条件
        if(root == NULL || root->val == val) return root;
        //因为二叉搜索树的节点大小是有规律的所以可以简化搜索
        if(root->val > val) return searchBST(root->left,val);
        if(root->val < val) return searchBST(root->right,val);
        return NULL; 

    }
};
```

#### 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
链接：https://leetcode.cn/problems/validate-binary-search-tree

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    //思路：中序遍历构建一个递增的数组
    vector<int> res;
    void travser(TreeNode* root){
        if(root == NULL) return;
        travser(root->left);
        res.push_back(root->val);
        travser(root->right);
    }
public:
    bool isValidBST(TreeNode* root) {
        res.clear();
        travser(root);
        for(int i = 1;i < res.size();i++){
            if(res[i] <= res[i - 1]){
                return false;
            }
        }
        return true;
    }
};

改进：
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pur = NULL;//记录前一个节点
    //TreeNode* cur = root;
    bool isValidBST(TreeNode* root) {
        if(root == NULL) return true;
        //中序遍历思路
        bool left = isValidBST(root->left);
        //相当于是中序遍历操作中在操作的判断
        //运用头结点pur判断是否是一个递增的序列
        if(pur != NULL && pur->val >= root->val) return false;
        pur = root;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

#### 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal(root->right);
}

public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;

    }
};

//设置双节点的另一种做法
class Solution {
private:
int result = INT_MAX;
TreeNode* pre;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur->left);   // 左
    if (pre != NULL){       // 中
        result = min(result, cur->val - pre->val);
    }
    pre = cur; // 记录前一个
    traversal(cur->right);  // 右
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```

#### 二叉搜索树中的众数

给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 任意顺序 返回。
链接：https://leetcode.cn/problems/find-mode-in-binary-search-tree

```c++
class Solution {
private:
    int maxCount; // 最大频率
    int count; // 统计频率
    TreeNode* pre;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // 左
                                    // 中
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre->val == cur->val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur->val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // 右
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    }
};

//迭代法
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int maxCount = 0; // 最大频率
        int count = 0; // 统计频率
        vector<int> result;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();                       // 中
                if (pre == NULL) { // 第一个节点
                    count = 1;
                } else if (pre->val == cur->val) { // 与前一个节点数值相同
                    count++;
                } else { // 与前一个节点数值不同
                    count = 1;
                }
                if (count == maxCount) { // 如果和最大值相同，放进result中
                    result.push_back(cur->val);
                }

                if (count > maxCount) { // 如果计数大于最大值频率
                    maxCount = count;   // 更新最大频率
                    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
                    result.push_back(cur->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

#### 二叉树/搜索树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree

```c++
//普通二叉树的最近祖先
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == NULL){
            return root; 
        }
        //寻找公共祖先的思路是要通过自底向上的后序遍历判断公共祖先
        TreeNode *left = lowestCommonAncestor(root->left,p,q);
        TreeNode *right = lowestCommonAncestor(root->right,p,q);
        //后序操作
        if(left != NULL && right != NULL) return root;

        if(left == NULL && right != NULL) return right;
        else if(left != NULL && right == NULL) return left;
        else{
            return NULL;
        }

        
    }
};

//二叉搜索树的最近祖先
//注意结合搜索区间进行判断
class Solution {
private:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if (cur == NULL) return cur;
                                                        // 中
        if (cur->val > p->val && cur->val > q->val) {   // 左
            TreeNode* left = traversal(cur->left, p, q);
            if (left != NULL) {
                return left;
            }
        }

        if (cur->val < p->val && cur->val < q->val) {   // 右
            TreeNode* right = traversal(cur->right, p, q);
            if (right != NULL) {
                return right;
            }
        }
        return cur;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
```



## BFS广度优先搜索

二叉树的广度优先搜索->二叉树的层序遍历；而讲到层序遍历，又可以把解题思路分成两种：递归法、迭代法。

这是主要写迭代法，因为相比于递归法的层序遍历，迭代法的BFS算法是最能体现出BFS思路的方法。

需要用到的数据结构：队列->准确的说是指针队列.

下面咱们就手撸一个BFS算法：

```c++
#include<iostream>
#include<queue>
#include<stdlib.h>
#include<vector>

using namespace std;

struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int BFS(TreeNode * root){
    if(root == NULL) return 0;  //终止条件判断
    queue<TreeNode*> que;   //创建队列
    que.push(root); //将根节点入队
    int sum = 0;//设置记录信号
    while(!que.empty()){
        sum = 0;//每次循环之前归零，记录单层的和
        int sz = que.size();//求出队列长度
        for(int i = 0;i < sz;i++){
            //for循环依次对每层求和
            TreeNode* cur = que.front();//取对头元素为初始指针节点
            que.pop();
            sum += cur->val;
            if(cur->left != NULL){
                que.push(cur->left);
            }
            if(cur->right != NULL){
                que.push(cur->right);
            }

        }
    }
    return sum;
}
```

广度优先搜索——本质上是二叉树的层序遍历（力扣102题）

运用的数据结构是队列和数组；运用数组保存最后的结果，运用队列去模拟层序遍历的过程。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## DFS深度优先搜索

深度优先搜索，顾名思义就是一条道路走到底；类比一棵树的话，就是从**上到下先序遍历**一棵树。深度优先，得到的一定先是树的深度（高度）。因为其通常和回溯算法相结合使用，所以其重要性不可估量。学会DFS就是学会使用其**暴力搜索**的功能，学会**聪明的穷举**。避免高强度的多循环嵌套for循环，既浪费时间又浪费空间；那为什么暴力搜索也需要花费大量时间但是还有它存在的道理呢？我认为，存在即合理，很多时候DFS算法存在确实是有他的优势的。最起码，DFS就是利用递归思维去书写程序的一个好模板。虽然本质上和for循环差别不大，但是，一旦问题规模变大，for循环承担不了大工程时，多层循环很容易把人绕懵而且时间复杂度是呈现n方量级增加。这时，DFS的递归遍历就节省了很大的空间复杂度（时间复杂度虽然不敢保证），避免了高强度的循环嵌套，使得程序得以运行出结果。同样，穷举与暴力是程序设计最本源的思路，计算机解决问题最开始的方法就是穷举，人们只是掌握了方法，让计算机学会去聪明的穷举。综上，这是我理解的DFS存在的现实意义与其重要性。

### DPS算法的设计分析

在学习书写DFS前一定要学会书写树的遍历（递归遍历）

```python
res.append(root.val)
preorder(root.left)
preorder(root.right)
```

理解了树的递归遍历之后，才能书写出DFS**递归的逻辑**。最本质的还是要理解递归的逻辑~

DFS书写套路：

1.定义存放结果变量

```c++
vector<vector<int>> res;//存放最终结果
vector<int> path;//存放路径
```

2.回溯函数的框架书写与参数的确定

```c++
void backtrack(参数......)
```

3.递归过程中搜索的逻辑

### DFS算法与回溯算法的关系

### DFS算法书写的模板套路

DFS的算法套路书写关键在于正确理解递归函数的参数调用与终止条件的确立。

## 回溯算法

回溯铺垫:二叉树的所有路径

```c++
**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void traversal(TreeNode* cur,vector<int> &path,vector<string> &res){

        path.push_back(cur->val);
        //到达叶子结点
        if(cur->left == NULL && cur->right == NULL){
            string spath;
            for(int i = 0;i < path.size() - 1;i++){
                spath += to_string(path[i]);
                spath += "->";
            }
            spath += to_string(path[path.size() - 1]);
            res.push_back(spath);
            return;
        }
        if(cur->left){
            traversal(cur->left,path,res);
            path.pop_back();//回溯
        }
        if(cur->right){
            traversal(cur->right,path,res);
            path.pop_back();//回溯
        }
    }
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        vector<int> path;
        if(root == NULL) return res;
        traversal(root,path,res);
        return res;
    }
};
```

回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：**回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」**。

回溯算法解决从上到下一次遍历整颗树，在其模板中，运用for循环去横向遍历——做选择；利用递归（回溯函数）去纵向遍历——路径。

路径、选择、终止条件

```python
#东哥模板
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

```c++
//卡哥模板
void backtrack(参数){
    if(终止条件){
        存放结果;
        return;
    }
    
    for(选择:本层集合中的元素){
        处理节点;
        backtrack(路径，选择);
        回溯,撤销结果;
    }
}
```

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作:

```python
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```

**写 `backtrack` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。

回溯法中的参数不是一次性就可以完全确定下来，一般先写逻辑，需要什么参数就可以填写什么参数。

——————————

无论是排列、组合还是子集问题，简单说无非就是让你从序列 `nums` 中以给定规则取若干元素，主要有以下几种变体：

**形式一、元素无重不可复选，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式**。

以组合为例，如果输入 `nums = [2,3,6,7]`，和为 7 的组合应该只有 `[7]`。

```c++
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}

/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式二、元素可重不可复选，即 `nums` 中的元素可以存在重复，每个元素最多只能被使用一次**。

以组合为例，如果输入 `nums = [2,5,2,1,2]`，和为 7 的组合应该有两种 `[2,2,2,1]` 和 `[5,2]`。

```c++
Arrays.sort(nums);
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，跳过值相同的相邻树枝
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}


Arrays.sort(nums);
/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式三、元素无重可复选，即 `nums` 中的元素都是唯一的，每个元素可以被使用若干次**。

上面用组合问题举的例子，但排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。

除此之外，题目也可以再添加各种限制条件，比如让你求和为 `target` 且元素个数为 `k` 的组合，那这么一来又可以衍生出一堆变体，怪不得面试笔试中经常考到排列组合这种基本题型。

```c++
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}


/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        backtrack(nums);
        // 撤销选择
        track.removeLast();
    }
}
```

**但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽**。

### 排列问题

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& nums,vector<bool>& used){
        //此时找到说明找到了一组
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0;i < nums.size();i++){
            if(used[i] == true) continue;//说明path中已经收集到了该元素
            used[i] = true;
            path.push_back(nums[i]);
            backtrack(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        res.clear();
        path.clear();
        vector<bool> used(nums.size(),false);
        backtrack(nums,used);
        return res;

    }
};

```

216.组合总数||

找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

只使用数字1到9，每个数字 最多使用一次 
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

```c++
class Solution {
private:
    //设置二维结果数组与路劲数组
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(int tarSum,int k,int sum,int startIndex){
        //此时找到了一组
        if(path.size() == k){
            if(sum == tarSum) res.push_back(path);
            return;
        }
        //单层递归的逻辑
        for(int i = startIndex;i <= 9;i++){
            sum += i;
            path.push_back(i);
            //注意参数的取值是i+1，调整下一层递归的startIndex
            backtrack(tarSum,k,sum,i + 1);
            sum -= i;//回溯
            path.pop_back();//回溯
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        res.clear();
        path.clear();
        backtrack(n,k,0,1);
        return res;

    }
};
```

### 组合总和

39：

给你一个 **无重复元素** 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150个。

```c++
class Solution {
private:
    //定义全局变量存放结果
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& candidates,int target,int sum,int startIndex){
        if(sum > target){
            return;
        }
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex;i <candidates.size();i++){
            sum += candidates[i];
            path.push_back(candidates[i]);
            //不需要i+1，表示可以从自身开始取
            backtrack(candidates,target,sum,i);
            sum -= candidates[i];
            path.pop_back();
            
        }
    }

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        path.clear();
        res.clear();
        backtrack(candidates,target,0,0);
        return res;

    }
};
```

40：

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。

注意本题与前一题的主要区别在于，本题中的candidates中存在重复的元素，在回溯过程中，同一层的遍历要注意避免重复元素的使用。

增加了used数组来判断重复元素的使用次数，从而避免重复元素的使用情况。

```c++
class Solution {
private:
    //定义全局变量
    //本题的区别在于，candidates中存在重复元素，要想办法进行去重
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& candidates, int target,int sum,int startIndex,vector<bool>& used){
        if(sum > target){
            return;
        }
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex;i < candidates.size() && sum + candidates[i] <= target;i++){
            if(i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false){
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtrack(candidates,target,sum,i + 1,used);
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(),false);
        path.clear();
        res.clear();
        sort(candidates.begin(),candidates.end());
        backtrack(candidates,target,0,0,used);
        return res;

    }
};
```

### 子集问题

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& nums,int startIndex){
        res.push_back(path);//收集子集要放在终止条件上面否则会漏掉
        if(startIndex >= nums.size()){
            return;
        }
        for(int i = startIndex;i < nums.size();i++){
            path.push_back(nums[i]);
            backtrack(nums,i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsets(vector<int>& nums) {
        path.clear();
        res.clear();
        backtrack(nums,0);
        return res;

    }
};
```

num中存在可重复元素时的情况时同样采用used数组进行重复避免。

**换句话说，我们通过保证元素之间的相对顺序不变来防止出现重复的子集**。

含有重复元素时一定要注意在最后主函数中**先对题给集合先进行排序**。

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtrack(vector<int>& nums,int startIndex,vector<bool>& used){
        res.push_back(path);
        if(startIndex >= nums.size()){
            return;
        }
        for(int i = startIndex;i < nums.size();i++){
            if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false){
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums,i + 1,used);
            used[i] = false;
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
        res.clear();
        path.clear();
        //去重要排序
        sort(nums.begin(),nums.end());
        backtrack(nums, 0, used);
        return res;
    }
};
```

### [N皇后](https://leetcode.cn/problems/n-queens)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

## 贪心算法

## 动态规划-Dynamic Programming

### 动态规划基础

->利用子问题的最优解去求解全局最优解;善于利用二位表寻找思路。

**动态规划问题的一般形式就是求最值**，动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多。既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。但是，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出**正确的「状态转移方程」**，才能正确地穷举。因此，写出状态转移方程的一般思路是：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 `dp` 数组/函数的含义**。

在**明确「选择」**的思考是就体现出来**“树”**的影子，可以画出树形结构来辅助思考最优解的路径

针对每道题应该有的思考：

1. **确定dp数组以及下标的含义**
    dp[i]的定义为：第i个数的斐波那契数值是dp[i]

2. **确定递推公式**
    为什么这是⼀道⾮常简单的⼊⻔题⽬呢？
    因为题⽬已经把递推公式直接给我们了：状态转移⽅程 dp[i] = dp[i - 1] + dp[i - 2];

3. **dp数组如何初始化**

   对于前提所需元素如何进行赋值；例如爬楼梯与斐波那契数列中dp[0]与dp[1]的赋值

4. **确定遍历顺序**
   从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序
   ⼀定是从前到后遍历的

5. **举例推导dp数组**

#### 动态规划书写框架

1.确定base case

2.穷举所有结果

3.状态转移

摆脱编程的黑盒状态：题目在于精；需要注意：每道题中**dp[]数组及其下标的含义**、**递推公式**、**dp数组如何初始化**、**遍历顺序**、**打印dp数组**。

动态规划的难点本来就在于寻找**正确的状态转移方程**，设计动态规划的通用技巧：**数学归纳思想**。

```python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

#### 斐波那契数列

斐波那契数列这道题⽬是⾮常基础的题⽬，通常⽤ F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后⾯的每⼀项
数字都是前⾯两项数字的和。

```c++
class Solution {
public:
	int fib(int N) {
		if (N <= 1) return N;
		vector<int> dp(N + 1);
		dp[0] = 0;
		dp[1] = 1;
		for (int i = 2; i <= N; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[N];
	}
};
```

->时间复杂度：O(n)
->空间复杂度：O(n)

改进：

```c++
class Solution {
public:
	int fib(int N) {
	if (N <= 1) return N;
	int dp[2];
	dp[0] = 0;
	dp[1] = 1;
	for (int i = 2; i <= N; i++) {
		int sum = dp[0] + dp[1];
		dp[0] = dp[1];
		dp[1] = sum;
	}
	return dp[1];
	}
};
```

->时间复杂度：O(n)
->空间复杂度：O(1)

#### 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

1. 确定dp数组以及下标的含义

dp[i]： **爬到第i层楼梯，有dp[i]种方法**

​	2.确定递推公式

如果可以推出dp[i]呢？

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是**dp[i - 1]**，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是**dp[i - 2]**，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 。

在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。

这体现出确定dp数组以及下标的含义的重要性！

​	3.dp数组如何初始化

在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。

那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.

**其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1**。

从dp数组定义的角度上来说，dp[0] = 0 也能说得通。

需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。

所以本题其实就不应该讨论dp[0]的初始化！

我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。

所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。

​	4.确定遍历顺序

从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的

​	5.举例推导dp数组

```c++
class Solution {
public:
    int climbStairs(int n) {
        //1.dp[i]含义：达到第i阶台阶的方法数量为dp[i]
        //2.确定递推公式dp[i] = dp[i-1] + dp[i-2]
        //3.初始化:dp[0] = 1/0;dp[1] = 1,dp[2] = 2
        if(n <= 1) return n;
        //vector<int> dp(n + 1);
        int dp[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3;i <= n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];


    }
};
```

空间复杂度优化

```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```

#### 使用最小花费爬楼梯

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

**每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯**.

**dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]**。dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];**注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的**，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值.

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
        return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
```

优化空间复杂度

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            int dpi = min(dp0, dp1) + cost[i];
            dp0 = dp1; // 记录一下前两位
            dp1 = dpi;
        }
        return min(dp0, dp1);
    }
};
```

### 背包问题

### 打家劫舍

### 股票问题

### 子序列问题

#### 两种思路

**第一种思路模板是一个一维的 `dp` 数组**

```Python
int n = array.length;
int[] dp = new int[n];

for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```

比如我们写过的 [最长递增子序列](https://labuladong.github.io/article/fname.html?fname=动态规划设计：最长递增子序列) 和 [最大子数组和](https://labuladong.github.io/article/fname.html?fname=最大子数组) 都是这个思路。

在这个思路中 `dp` 数组的定义是：

**在子数组 `arr[0..i]` 中，我们要求的子序列（最长递增子序列）的长度是 `dp[i]`**。

**第二种思路模板是一个二维的 `dp` 数组**

```python
int n = arr.length;
int[][] dp = new dp[n][n];

for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
```

->**涉及两个字符串/数组的场景**，`dp` 数组的定义如下：

**在子数组 `arr1[0..i]` 和子数组 `arr2[0..j]` 中，我们要求的子序列长度为 `dp[i][j]`**。

->**只涉及一个字符串/数组的场景**，`dp` 数组的定义如下：

**在子数组 `array[i..j]` 中，我们要求的子序列的长度为 `dp[i][j]`**。

## 

